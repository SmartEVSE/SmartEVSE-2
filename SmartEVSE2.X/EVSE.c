/*
; Project:       Smart EVSE
;
; Changes:
;
; 2.00  New v2 hardware (18F26K22), Graphic 128x64 LCD , MPLAB X IDE, and the XC8 compiler
; 2.01  Fix: Charge current in normal mode was limited to MaxMains setting.
;       Fix: Load Balancing-Master can now adjust MaxMains and MinCharge settings from the LCD menu.
;       Fix: SmartMode can now charge at a higher current then set by MaxMains, using surplus power generated by Solar.
;            i.e. -15A PV power +45A MaxMains results in charging current of 60A.
;       Bugfixes to load balancing code (only affects v2)
; 2.02  Fix: Node Max charge current was set to Cable limit instead of MaxCurrent
;       Fix: Charging sometimes stopped because State C control pilot ranges were too strict.
; 2.03  Changed lowest MaxMains setting to 10A, lowest CT calibration value to 6A.
; 2.04  Fix: In Normal mode, the MAX charge current was limited by the MAINS setting (which is not shown in this mode).
;       Fix: default LoadBl EEPROM setting was not set correctly.
;       MAX charge current can be adjusted while charging in Normal mode.
;       ACCESS menu option added. Allows to Start/Stop charging by connecting a button/switch to IO2.
;       if the ACCESS option is set to disabled, the button can be used to stop charging.
;       On IO1 a LED can be connected, which acts as a charging/error indicator.
; 2.05  Fix: Using a 16A charge cable would limit MaxCurrent to 16A, until a reset of the module or adjusting the MAX value using the menu.
;       Fix: Increased number of times a STATE change needs to be valid, before the actual STATE change takes place.
;            this to fix erratic behavior on a Renault Zoe.
;       LCD Backlight will now be activated on any key press, and will turn off after 60 seconds of inactivity (except when charging).
;       CT's default values can be restored by holding both < and > keys while in the CAL menu.
;       RCMON menu option added. This adds support for DC Residual Current sensors, as required by IEC62955.
;            IO3 is used as the fault input (active high).
;            The error state can be reset by pressing any module button, or the pushbutton on IO2
; 2.06  Added check in EEprom write routine for disabled interrupts.
; 2.07  Fix: The RCD was tripped by inductive loads/ voltage spikes on the mains line. Checking twice for a tripped RCD fixed this.
;       Bootloader can now only be entered when also the right button on top of the module is pressed.
;       Added Compile time option to switch directly from STATE_A to STATE_C.
;
; 2.10  Modbus version.
;       Please note that the old sensorbox will -not- work with this version.
;       Use Sensorbox 1.5 or Sensorbox 2, or use a Phoenix, Finder or Eastrom modbus kWh meter for measuring the current on your mains wiring.
;       Thanks to Robert Heel for his work on this code.
;       Added MODE Solar option. Maximize charging on Solar power.
;       Added START menu option. Start Charging when surplus solar power is above 4A (configurable 1-16 A). EV will always charge at minimal MIN Current per phase
;       Added STOP menu option. Stop Charging after XX minutes at MIN charge current (configurable 0-60 min) (0= keep charging)
;       EEprom initialization done at first power-up.
;       Bugfixes in Master/Node code.
;       Automatic CT Calibration reset when upgrading from 2.0x to this version.
;       LCD Backlight will now be lit for 60 seconds, when pressing the external button.
;       CABLE option removed, just set MAX to the cable capacity.
;       CIRCUIT menu option added. Used when multiple EVSE's share the same circuit. Set this to the max current of the EVSE circuit.
;       Switching between Solar/Smart mode with left button on the module.
; 2.11  Fixed rare corrupted flash issue, seems to happen sometimes at power on.
;       The microcontroller would start at a random address, if this happened to be the flash erase code, the flash will become corrupted.
;       Now using two variables that hold the unlock sequence. So that power up glitches will not trigger a flash erase/write.
;       Bootloader also gets updated to fix this issue (now v1.06)
;       MAX setting now starts at 6A
; 2.12  Fixed garbled LCD. When charging is stopped the the LCD is re-initialized after a 200ms delay.
; 2.13  Various Master/Node communication bug fixes.
; 2.14  Fixed Broadcast error clear message handling on node.
;       Added check in Solar mode for overloading the MAINS.
;       Removed START and STOP menu options from the node, as it is determined by the master.
; 2.15  Added check to see if Sensorbox data contains new measurement data.
;       Added IMPORT menu option, which allows for power import from the grid when solar charging.
;       Added compile time option to compensate for 230V-400V transformers.
;       Added Activation mode, which is triggered if state C is not entered within 30 seconds.
;       If an external push button is used as Smart/Solar mode switch, holding this button for 1.5 seconds will now stop charging.
; 2.16  Fixed Smart/Solar mode switch, it would force Solar or Smart mode, even in Normal mode.
;       Added GRID menu option. Configures the Sensorbox2 for use with 4Wire (L1,L2,L3 and Neutral) or 3Wire (L1,L2,L3 no Neutral)
;       Speeded up State C->B detection, by removing (blocking) delays. The Renault ZOE will show an error if this takes > 100ms.
; 2.17  Fixed state switch bug while in solar mode.
;       Hides CAL menu option when CT's are not used.
; 2.20  Fixed Temp Error, >65C stopped charging, but did not show any error message on the LCD.
;       Internal temperature is now displayed on the LCD while in the setup menu.
;       Added setup menu navigation indicator, which shows how many menu options are available, and which one is currently selected.
;       Fixed MAX current adjustment above initial setting, while charging and a FIXED cable is used.
;       Added EVMETER and EVADR option to the menu. Use a modbus kWh meter to measure the charged energy.
;       Added charged energy to the LCD (Smart/Solar mode)
;       Uses condensed characters on the LCD, so the 'i' will not use the same space as the 'w'
;       Increased MaxMains to 200A, and Circuit to 160A.
;       Allows the use of 200A:50ma CT's with the Sensorbox. Will adjust (x2) measurement when MAINS setting is >100A
;       Increased the nr of nodes to 7.
;       Added modbus node polling. The master will poll all nodes for state changes.
;       Added RFID reader option. Learn up to 20 RFID cards.
;           Enabling the RFID reader will lock/unlock the SmartEVSE with a valid RFID card.
;           Status messages when learning/deleting cards are displayed on the LCD.
;           Erase all cards by selecting EraseAll from the menu, and then Exit Menu.
; 2.30  Rearranged the modbus registers.
;       Set modbus address 0x01 when load balancing is disabled.
;       Interrupt sending modbus requests for 4 seconds when receiving requests from another device to avoid collisions.
;       Added RFID EnableOne option, that will allow only the RFID card to unlock the EVSE that lock (start charge) the EVSE.
;           In this mode it will lock the charging cable when connected, and only unlock the cable if the same RFID card
;           is presented (like a public charging station)
;       Allow custom meter FUNCTION config.
;       Added support for WAGO electric meter and SolarEdge Inverter in SunSpec mode.
;
;
;   Build with MPLAB X v5.25 and XC8 compiler version 2.10
;
;   If you get "(902) no chip name specified" error messages, make sure the xc8-cc compiler is used.
;
;   set in XC8 global options the C standard to "C90"
;   set XC8 linker memory model settings to: double 32 bit, float 32 bit
;   and reserve space for the bootloader by setting ROM range to 0-FCFB
;
;
;   (C) 2013-2022  Michael Stegen / Stegen Electronics
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
*/

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xc.h>

#include "bootloader.h"
#include "EVSE.h"
#include "GLCD.h"
#include "modbus.h"
#include "OneWire.h"
#include "utils.h"


// Configuration settings
#pragma	config FCMEN = OFF,	IESO = OFF, PRICLKEN = ON
#pragma config PLLCFG = OFF, FOSC = HSMP                                        // High Speed Medium power (4-16Mhz), PLL Off
#pragma	config BORV = 285, BOREN = ON, PWRTEN = ON
#pragma	config WDTPS = 2048, WDTEN = OFF                                        // WDT timeout
#pragma config CCP2MX = PORTB3, PBADEN = OFF, CCP3MX = PORTC6                   // PortB digital IO
#pragma config HFOFST = OFF, T3CMX = PORTB5, P2BMX = PORTC0, MCLRE = INTMCLR

#pragma config XINST = OFF, DEBUG = OFF, LVP = OFF, STVREN = ON
#pragma	config CP0 = OFF, CP1 = OFF, CP2 = OFF, CP3 = OFF, CPD = OFF, CPB = OFF
#pragma	config WRT0 = OFF, WRT1 = OFF, WRT2 = OFF, WRT3 = OFF
#pragma	config WRTC = OFF, WRTB = OFF, WRTD = OFF
#pragma	config EBTR0 = OFF, EBTR1 = OFF, EBTR2 = OFF, EBTR3 = OFF
#pragma	config EBTRB = OFF


// Text
const char StrFixed[]   = "Fixed";
const char StrSocket[]  = "Socket";
const char StrSmart[]   = "Smart";
const char StrNormal[]  = "Normal";
const char StrSolar[]   = "Solar";
const char StrSolenoid[] = "Solenoid";
const char StrMotor[]   = "Motor";
const char StrDisabled[] = "Disabled";
const char StrLoadBl[9][9]  = {"Disabled", "Master", "Node 1", "Node 2", "Node 3", "Node 4", "Node 5", "Node 6", "Node 7"};
const char StrSwitch[5][10] = {"Disabled", "Access B", "Access S", "Sma-Sol B", "Sma-Sol S"};
const char StrGrid[2][10] = {"4Wire", "3Wire"};
const char StrEnabled[] = "Enabled";
const char StrExitMenu[] = "MENU";
const char StrMainsAll[] = "All"; // Everything
const char StrMainsHomeEVSE[] = "Home+EVSE";
const char StrRFIDReader[6][10] = {"Disabled", "EnableAll", "EnableOne", "Learn", "Delete", "DeleteAll"};
const char StrStateName[11][10] = {"A", "B", "C", "D", "COMM_B", "COMM_B_OK", "COMM_C", "COMM_C_OK", "Activate", "B1", "C1"};
const char StrWiFi[3][10] = {"Disabled", "Enabled", "SetupWifi"};

// Global data
char U1buffer[MODBUS_BUFFER_SIZE], U1packet[MODBUS_BUFFER_SIZE];                // Uart1 Receive buffer /RS485
char U1TXbuffer[MODBUS_BUFFER_SIZE];                                            // Uart1 Transmit buffer /RS485
char U2buffer[50];                                                              // Uart2 buffer /Serial CLI
char GLCDbuf[512];                                                              // GLCD buffer (half of the display)


// The following data will be updated by eeprom data at powerup:
unsigned int MaxMains = MAX_MAINS;                                              // Max Mains Amps (hard limit, limited by the MAINS connection) (A)
unsigned int MaxCurrent = MAX_CURRENT;                                          // Max Charge current (A)
unsigned int MinCurrent = MIN_CURRENT;                                          // Minimal current the EV is happy with (A)
unsigned long ICal = ICAL;                                                      // CT calibration value
unsigned char Mode = MODE;                                                      // EVSE mode (0:Normal / 1:Smart / 2:Solar)
char Lock = LOCK;                                                               // Cable lock (0:Disable / 1:Solenoid / 2:Motor)
unsigned int MaxCircuit = MAX_CIRCUIT;                                          // Max current of the EVSE circuit (A)
char Config = CONFIG;                                                           // Configuration (0:Socket / 1:Fixed Cable)
char LoadBl = LOADBL;                                                           // Load Balance Setting (0:Disable / 1:Master / 2-4:Node)
char Switch = SWITCH;                                                           // External Switch on I/O 2 (0:Disable / 1:Access / 2:Smart-Solar)
char RCmon = RC_MON;                                                            // Residual Current Monitor on I/O 3 (0:Disable / 1:Enable)
unsigned int StartCurrent = START_CURRENT;
unsigned int StopTime = STOP_TIME;
unsigned int ImportCurrent = IMPORT_CURRENT;
unsigned char MainsMeter = MAINS_METER;                                         // Type of Mains electric meter (0: Disabled / Constants EM_*)
unsigned char MainsMeterAddress = MAINS_METER_ADDRESS;
unsigned char MainsMeterMeasure = MAINS_METER_MEASURE;                          // What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
unsigned char PVMeter = PV_METER;                                               // Type of PV electric meter (0: Disabled / Constants EM_*)
unsigned char PVMeterAddress = PV_METER_ADDRESS;
char Grid = GRID;                                                               // Type of Grid connected to Sensorbox (0:4Wire / 1:3Wire )
unsigned char EVMeter = EV_METER;                                               // Type of EV electric meter (0: Disabled / Constants EM_*)
unsigned char EVMeterAddress = EV_METER_ADDRESS;
unsigned char RFIDReader = RFID_READER;                                         // RFID Reader Disabled/Enabled (Learn / Delete, Delete All)
unsigned char WIFImode = WIFI_MODE;                                             // WiFi Mode (0:Disabled / 1:Enabled / 2:Start Portal)

signed int Irms[3]={0, 0, 0};                                                   // Momentary current per Phase (23 = 2.3A) (resolution 100mA)
signed int Imem[3];                                                             // Max 3 phases supported

unsigned char State = STATE_A;
unsigned char Error = NO_ERROR;
unsigned char NextState;

unsigned int MaxCapacity;                                                       // Cable limit (A) (limited by the wire in the charge cable, set automatically, or manually if Config=Fixed Cable)
unsigned int ChargeCurrent;                                                     // Calculated Charge Current (Amps *10)
unsigned int OverrideCurrent = 0;                                               // Temporary assigned current (Amps *10) (modbus)
signed int Imeasured = 0;                                                       // Max of all Phases (Amps *10) of mains power
signed int Isum = 0;                                                            // Sum of all measured Phases (Amps *10) (can be negative)

// Load Balance variables
signed int IsetBalanced = 0;                                                    // Max calculated current (Amps *10) available for all EVSE's
unsigned int Balanced[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                     // Amps value per EVSE
unsigned int BalancedMax[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                  // Max Amps value per EVSE
char BalancedState[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                        // State of all EVSE's 0=not active (state A), 1=charge request (State B), 2= Charging (State C)
unsigned int BalancedError[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};                // Error state of EVSE
struct NodeStatus Node[NR_EVSES] = {                                            // 0: Master / 1: Node 1 ...
   /*         Config   EV     EV       Min                    *
    * Online, Changed, Meter, Address, Current, Phases, Timer */
    {   true,       0,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 },
    {  false,       1,     0,       0,       0,      0,     0 }
};

unsigned char RX1byte;
unsigned char idx = 0, idx2 = 0, ISRFLAG = 0, ISR2FLAG = 0, ISRTXFLAG = 0, ISRTXLEN = 0;
unsigned char menu = 0;
unsigned int locktimer = 0, unlocktimer = 0;                                    // solenoid timers
unsigned char lock1 = 0, lock2 = 1;
unsigned char UnlockCable = 0, LockCable = 0;
unsigned long Timer = 0;                                                        // mS counter
unsigned long ModbusTimer;
unsigned char BacklightTimer = 0;                                               // Backlight timer (sec)
unsigned int ChargeTimer = 0;                                                   // Counts seconds in STATE C (Charging) (unused)
unsigned char LCDTimer = 0;
signed char TempEVSE = 0;                                                       // Temperature EVSE in deg C (-50 to +125)
unsigned char ButtonState = 0x0f;                                               // Holds latest push Buttons state (LSB 3:0)
unsigned char OldButtonState = 0x0f;                                            // Holds previous push Buttons state (LSB 3:0)
unsigned char LCDNav = 0;
unsigned char SubMenu = 0;
unsigned long ScrollTimer = 0;
unsigned char LCDpos = 0;
unsigned char ChargeDelay = 0;                                                  // Delays charging at least 60 seconds in case of not enough current available.
unsigned char C1Timer = 0;
unsigned char NoCurrent = 0;                                                    // counts overcurrent situations.
unsigned char TestState = 0;
unsigned char LedTimer = 0;                                                     // LED on I01 uses TMR2 and a PWM signal to fade in/out
unsigned char LedUpdate = 0;                                                    // Flag that LED PWM data has been updated
unsigned char LedCount = 0;                                                     // Raw Counter before being converted to PWM value
unsigned char LedPwm = 0;                                                       // PWM value 0-255
unsigned char ModbusRequest = 0;                                                // Flag to request Modbus information
unsigned char MenuItems[MENU_EXIT];
unsigned char unlockMagic = 0;
unsigned char unlock55 = 0;                                                     // unlock bytes set to 0 to prevent flash write at por
unsigned char unlockAA = 0;                                                     // unlock bytes set to 0 to prevent flash write at por
unsigned char Access_bit = 0;
unsigned char ConfigChanged = 0;
unsigned int serialnr = 0;
unsigned char GridActive = 0;                                                   // When the CT's are used on Sensorbox2, it enables the GRID menu option.
unsigned char CalActive = 0;                                                    // When the CT's are used on Sensorbox(1.5 or 2), it enables the CAL menu option.
unsigned char SB2SoftwareVer = 0;                                               // Sensorbox 2 software version
unsigned int Iuncal = 0;                                                        // Uncalibrated CT1 measurement (resolution 10mA)
unsigned char DiodeCheck = 0, ActivationMode = 0;

unsigned int SolarStopTimer = 0;
unsigned char DelayedRS485SendBuf = 0;
signed long EnergyCharged = 0;                                                  // kWh meter value energy charged. (Wh) (will reset if state changes from A->B)
signed long EnergyMeterStart = 0;                                               // kWh meter value is stored once EV is connected to EVSE (Wh)
signed long PowerMeasured = 0;                                                  // Measured Charge power in Watt by kWh meter
unsigned char RFIDstatus = 0;
unsigned char ExternalMaster = 0;
unsigned char EVMeasureNode = 255;
unsigned char CMMeasureNode = 0;
unsigned char CMMeasureTimer = 0;
bool CMMeasured = false;

unsigned char LocalTimeSet = 0;
unsigned char WiFiAPSTA = 0;
unsigned char WiFiConnected = 0;
unsigned char WIFImodeSB = 0;
unsigned char tm_hour = 0, tm_min = 0;                                          // hours since midnight 0-23, minutes after the hour 0-59
unsigned char tm_mday = 0, tm_mon = 0;                                          // day of the month 1-31, months since January 0-11
unsigned char tm_year = 0, tm_wday = 0;                                         // years since 1900, days since Sunday 0-6
unsigned char SensorboxIP[4] = {0, 0, 0, 0};
unsigned int SensorboxMAC = 0;
char APpassword[] = "00000000";


void interrupt high_isr(void)
{
    // Determine what caused the interrupt
    while (PIR1bits.RC1IF)                                                      // Uart1 receive interrupt? RS485
    {
        RX1byte = RCREG1;                                                       // copy received byte

        if (ModbusTimer > 3)                                                    // last reception more then 3ms ago?
        {
            idx = 0;                                                            // clear idx in RS485 RX handler
        }
        if (idx == MODBUS_BUFFER_SIZE) idx--;                                   // max bytes in buffer
        U1buffer[idx++] = RX1byte;                                              // Store received byte in buffer

        ModbusTimer = 0;
    }

    if (PIR1bits.TX1IF && PIE1bits.TX1IE)                                       // Uart1 transmit interrupt? RS485
    {
        TXREG1 = U1TXbuffer[ISRTXFLAG++];                                       // send character
        if ((ISRTXFLAG == ISRTXLEN)|| ISRTXFLAG == MODBUS_BUFFER_SIZE)          // end of buffer
        {
            PIE1bits.TX1IE = 0;                                                 // clear transmit Interrupt for RS485 after sending last character
            ISRTXFLAG = 0;                                                      // end of transmission.
        }                                                                       // we switch off the transmitter in the main loop, after the final character has been sent..
        ModbusTimer = 0;                                                        // make sure there is a delay between modbus packets
    }

    // Uart2 receive interrupt?
    while (PIR3bits.RC2IF)
    {
        // Check for BREAK character, then Reset
        if (RCSTA2bits.FERR && RCONbits.POR && State != STATE_C ) {
                                                                                // Make sure any data during a POR is ignored.
            RX1byte = RCREG2;                                                   // copy received byte
            if (!RX1byte) Reset();                                              // Only reset if not charging...
        } else RX1byte = RCREG2;

        RCONbits.POR = 1;                                                       // flag that future resets are not POR resets

        TXREG2 = RX1byte;                                                       // echo to UART2 port, don't check for overflow here.
        if (idx2 == 50) idx2--;
        if ((RX1byte == 0x08) && (idx2 > 0)) {
            idx2--;                                                             // backspace
        } else {
            if (RX1byte == 0x0d || RX1byte == 0x0a)                             // CR or LF?
            {
                RX1byte = 0;
                ISR2FLAG = idx2 + 1u;                                           // ENTER, process data
            }
            U2buffer[idx2++] = RX1byte;                                         // store byte
        }
    }

    // Timer 4 interrupt, called 1000 times/sec
    while (PIR5bits.TMR4IF)
    {
        if (Lock)                                                               // Cable lock enabled?
        {
            // Unlock Cable
            if (UnlockCable) {
                if (unlocktimer < 600) {                                        // 600ms pulse
                    SOLENOID_UNLOCK;
                } else SOLENOID_OFF;
                if (unlocktimer++ > 700) {
                    if (PORTCbits.RC1 == lock1 )                                // still locked...
                    {
                        if (unlocktimer > 5000) unlocktimer = 0;                // try to unlock again in 5 seconds
                    } else unlocktimer = 700;
                }
                locktimer = 0;
            // Lock Cable
            } else if (LockCable) {
                if (locktimer < 600) {                                          // 600ms pulse
                    SOLENOID_LOCK;
                } else SOLENOID_OFF;
                if (locktimer++ > 700) {
                    if (PORTCbits.RC1 == lock2 )                                // still unlocked...
                    {
                        if (locktimer > 5000) locktimer = 0;                    // try to lock again in 5 seconds
                    } else locktimer = 700;
                }
                unlocktimer = 0;
            }
        }

        Timer++;                                                                // mSec counter (overflows in 1193 hours)
        ModbusTimer++;

        if (LedTimer-- == 0) {
            CCPR2L = LedPwm;                                                    // MSB of DutyCycle, Lsb 0-1 are part of CCP2CON, but not used
                                                                                // LedPwm is calculated in the main loop
            LedTimer = 10;                                                      // Led is updated every 10ms (1ms*10)
            LedUpdate = 1;                                                      // Flag that LED PWM value has been updated
        }

        PIR5bits.TMR4IF = 0;                                                    // clear interrupt flag
    }

}


// Copy modbus frame to output buffer
// Start RS485 transmission, by enabling TX interrupt
void RS485SendBuf(char *buffer, unsigned char len) {
    unsigned char index = 0;

#ifdef LOG_INFO_MODBUS
    printf("\nSend packet");
#endif
#ifdef LOG_DEBUG_MODBUS
    for (unsigned char i=0; i<len; i++) printf(" %02X", buffer[i]);
#endif
    while (ISRTXFLAG) {}                                                        // wait if we are already transmitting on the RS485 bus (blocking, does not occur?)
    ISRTXLEN = len;                                                             // number of bytes to transfer

    while (len--) {
        U1TXbuffer[index++] = *buffer++;                                        // load next byte
    }

    if (ModbusTimer > 6) {                                                      // No RS485 reception at the moment

        LATBbits.LATB5 = 1;                                                     // set RS485 transceiver to transmit
        delay(1);
        PIE1bits.TX1IE = 1;                                                     // enable transmit Interrupt for RS485
    } else DelayedRS485SendBuf = 1;                                             // RS485 reception taking place, handle sending of frame in main loop

}

void eeprom_read_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    EECON1 = 0;                                                                 // select EEprom
                                                                                // EEADR needs to be initialized
    while (obj_size--) {
        EECON1bits.RD = 1;
        *p++ = EEDATA;
        EEADR++;
    }
}

void eeprom_write_object(void *obj_p, size_t obj_size) {
    unsigned char *p = obj_p;

    while (obj_size--) {
        EECON1 = 0;                                                             // ensure CFGS=0 and EEPGD=0
        EECON1bits.WREN = 1;                                                    // enable write to EEPROM

        EEDATA = *p++;                                                          // set data
        if (!INTCONbits.GIE)                                                    // Interrupts should have been disabled!
        {
            EECON2 = unlock55;                                                  // required sequence #1
            EECON2 = unlockAA;                                                  // #2
            EECON1bits.WR = 1;                                                  // #3 = actual write
            while (EECON1bits.WR);                                              // blocking
        }
        EECON1bits.WREN = 0;                                                    // disable write to EEPROM
        EEADR++;
    }
}

/**
 * Validate setting ranges and dependencies
 */
void validate_settings(void) {
    unsigned char i;
    unsigned int value;

    for (i = MENU_ENTER + 1;i < MENU_EXIT; i++){
        value = getItemValue(i);
        //printf("value %s set to %i\n",MenuStr[i].Key, value );
        if (value > MenuStr[i].Max || value < MenuStr[i].Min) {
            value = MenuStr[i].Default;
          //  printf("set default value for %s to %i\n",MenuStr[i].Key, value );
            setItemValue(i, value);
        }
    }

    // RFID reader set to Enable One card, the EVSE is disabled by default
    if (RFIDReader == 2) Access_bit = 0;
    // Enable access if no access switch used
    else if (Switch != ACCESS_BUTTON && Switch != ACCESS_SWITCH) Access_bit = 1;
    // Sensorbox v2 has always address 0x0A
    if (MainsMeter == EM_SENSORBOX) MainsMeterAddress = 0x0A;
    // Disable modbus reception on normal mode
    if (Mode == MODE_NORMAL) { MainsMeter = 0; PVMeter = 0; }
    // Disable PV reception if not configured
    if (MainsMeterMeasure == 0) PVMeter = 0;
    // set Lock variables for Solenoid or Motor
    if (Lock == 1) { lock1=0; lock2=1; }
    else if (Lock == 2) { lock1=1; lock2=0; }
    // Erase all RFID cards from ram + eeprom if set to EraseAll
    if (RFIDReader == 5) {
        DeleteAllRFID();
    }

    // Update master node config
    Node[0].EVMeter = EVMeter;
    Node[0].EVAddress = EVMeterAddress;

    // Default to modbus input registers
    if (EMConfig[EM_CUSTOM].Function != 3) EMConfig[EM_CUSTOM].Function = 4;

    // Backward compatibility < 2.20
    if (EMConfig[EM_CUSTOM].IRegister == 8 || EMConfig[EM_CUSTOM].URegister == 8 || EMConfig[EM_CUSTOM].PRegister == 8 || EMConfig[EM_CUSTOM].ERegister == 8) {
        EMConfig[EM_CUSTOM].DataType = MB_DATATYPE_FLOAT32;
        EMConfig[EM_CUSTOM].IRegister = 0;
        EMConfig[EM_CUSTOM].URegister = 0;
        EMConfig[EM_CUSTOM].PRegister = 0;
        EMConfig[EM_CUSTOM].ERegister = 0;
    }
}

void read_settings(void) {

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_read_object(&MaxMains, sizeof MaxMains);
    if (MaxMains > 200) {                                                       // check if the eeprom is uninitialized
        MaxMains = MAX_MAINS;                                                   // set MaxMains back to default value
        write_settings();                                                       // uninitialized, write default settings to eeprom
        return;
    }

    eeprom_read_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_read_object(&MinCurrent, sizeof MinCurrent);
    eeprom_read_object(&ICal, sizeof ICal);
    eeprom_read_object(&Mode, sizeof Mode);
    eeprom_read_object(&Lock, sizeof Lock);
    eeprom_read_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_read_object(&Config, sizeof Config);
    eeprom_read_object(&LoadBl, sizeof LoadBl);
    eeprom_read_object(&Switch, sizeof Switch);
    eeprom_read_object(&RCmon, sizeof RCmon);
    eeprom_read_object(&StartCurrent, sizeof StartCurrent);
    eeprom_read_object(&StopTime, sizeof StopTime);
    eeprom_read_object(&MainsMeter, sizeof MainsMeter);
    eeprom_read_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_read_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_read_object(&PVMeter, sizeof PVMeter);
    eeprom_read_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_read_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_read_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_read_object(&Grid, sizeof Grid);
    eeprom_read_object(&EVMeter, sizeof EVMeter);
    eeprom_read_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_read_object(&RFIDReader, sizeof RFIDReader);
    eeprom_read_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_read_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);
    eeprom_read_object(&EMConfig[EM_CUSTOM].DataType, sizeof EMConfig[EM_CUSTOM].DataType);
    eeprom_read_object(&EMConfig[EM_CUSTOM].Function, sizeof EMConfig[EM_CUSTOM].Function);
    eeprom_read_object(&WIFImode, sizeof WIFImode);

    validate_settings();
}

void write_settings(void) {
    char savint;

    unlock55 = unlockMagic + 0x33u;
    unlockAA = unlockMagic + 0x88u;                                             // set unlock variables to magic values

    validate_settings();

    savint = INTCON;                                                            // Save interrupts state
    INTCONbits.GIE = 0;                                                         // Disable interrupts

    EEADR = 0;                                                                  // start from adr 0 in eeprom
    EEADRH = 0;                                                                 // we only use the first 256 bytes for now.

    eeprom_write_object(&MaxMains, sizeof MaxMains);
    eeprom_write_object(&MaxCurrent, sizeof MaxCurrent);
    eeprom_write_object(&MinCurrent, sizeof MinCurrent);
    eeprom_write_object(&ICal, sizeof ICal);
    eeprom_write_object(&Mode, sizeof Mode);
    eeprom_write_object(&Lock, sizeof Lock);
    eeprom_write_object(&MaxCircuit, sizeof MaxCircuit);
    eeprom_write_object(&Config, sizeof Config);
    eeprom_write_object(&LoadBl, sizeof LoadBl);
    eeprom_write_object(&Switch, sizeof Switch);
    eeprom_write_object(&RCmon, sizeof RCmon);
    eeprom_write_object(&StartCurrent, sizeof StartCurrent);
    eeprom_write_object(&StopTime, sizeof StopTime);
    eeprom_write_object(&MainsMeter, sizeof MainsMeter);
    eeprom_write_object(&MainsMeterAddress, sizeof MainsMeterAddress);
    eeprom_write_object(&MainsMeterMeasure, sizeof MainsMeterMeasure);
    eeprom_write_object(&PVMeter, sizeof PVMeter);
    eeprom_write_object(&PVMeterAddress, sizeof PVMeterAddress);
    eeprom_write_object(&EMConfig[EM_CUSTOM].Endianness, sizeof EMConfig[EM_CUSTOM].Endianness);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IRegister, sizeof EMConfig[EM_CUSTOM].IRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].IDivisor, sizeof EMConfig[EM_CUSTOM].IDivisor);
    eeprom_write_object(&ImportCurrent, sizeof ImportCurrent);
    eeprom_write_object(&Grid, sizeof Grid);
    eeprom_write_object(&EVMeter, sizeof EVMeter);
    eeprom_write_object(&EVMeterAddress, sizeof EVMeterAddress);
    eeprom_write_object(&RFIDReader, sizeof RFIDReader);
    eeprom_write_object(&EMConfig[EM_CUSTOM].URegister, sizeof EMConfig[EM_CUSTOM].URegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].UDivisor, sizeof EMConfig[EM_CUSTOM].UDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PRegister, sizeof EMConfig[EM_CUSTOM].PRegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].PDivisor, sizeof EMConfig[EM_CUSTOM].PDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].ERegister, sizeof EMConfig[EM_CUSTOM].ERegister);
    eeprom_write_object(&EMConfig[EM_CUSTOM].EDivisor, sizeof EMConfig[EM_CUSTOM].EDivisor);
    eeprom_write_object(&EMConfig[EM_CUSTOM].DataType, sizeof EMConfig[EM_CUSTOM].DataType);
    eeprom_write_object(&EMConfig[EM_CUSTOM].Function, sizeof EMConfig[EM_CUSTOM].Function);
    eeprom_write_object(&WIFImode, sizeof WIFImode);

    unlock55 = 0;                                                               // clear unlock values
    unlockAA = 0;

    INTCON = savint;                                                            // Restore interrupts
#ifdef LOG_INFO_EVSE
    printf("\nsettings saved\n");
#endif

    if (LoadBl == 1) {                                                          // Master mode
        unsigned int i, values[MODBUS_SYS_CONFIG_COUNT];
        for (i = 0; i < MODBUS_SYS_CONFIG_COUNT; i++) {
            values[i] = getItemValue(MENU_MODE + i);
        }
        // Broadcast settings to other controllers
        ModbusWriteMultipleRequest(BROADCAST_ADR, MODBUS_SYS_CONFIG_START, values, MODBUS_SYS_CONFIG_COUNT);
    }

    ConfigChanged = 1;
}

void putch(unsigned char byte)                                                  // user defined printf support on uart2
{
    // output one byte on UART2
    while (!PIR3bits.TX2IF);                                                    // set when register is empty (blocking)
    TXREG2 = byte;

}

unsigned char ReadPilot(void)                                                   // Read Pilot Signal
{
    ADCON0bits.GO = 1;                                                          // start ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)
    if (ADRES > 980) return PILOT_12V;                                          // Pilot at 12V (min 11.0V)
    if ((ADRES > 860) && (ADRES < 915)) return PILOT_9V;                        // Pilot at 9V
    if ((ADRES > 720) && (ADRES < 800)) return PILOT_6V;                        // Pilot at 6V
    if ((ADRES > 25) && (ADRES < 95)) return PILOT_DIODE;                       // Diode Check OK
    return PILOT_NOK;                                                           // Pilot NOT ok
}

void ProximityPin(void) {
    ADCON0 = 0b00000101;                                                        // ADC input AN1 (Proximity Pin)
    delay(100);                                                                 // delay 100ms (blocking)
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    MaxCapacity = 13;                                                           // No resistor, Max cable current = 13A
    if ((ADRES > 394) && (ADRES < 434)) MaxCapacity = 16;                       // Max cable current = 16A	680R
    if ((ADRES > 175) && (ADRES < 193)) MaxCapacity = 32;                       // Max cable current = 32A	220R
    if ((ADRES > 88) && (ADRES < 98)) MaxCapacity = 63;                         // Max cable current = 63A	100R

    if (Config) MaxCapacity = MaxCurrent;                                       // Override with MaxCurrent when Fixed Cable is used.

    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
}

void Temp(void)                                                                 // Measure Temperature EVSE (0-125 C)
{
    unsigned int temp;

    ADCON0 = 0b00001001;                                                        // ADC input AN2 (Temperature Sensor)
    ADCON1 = 0b00001000;                                                        // Use VREF 2.048V
    ADCON2 = 0b10111101;                                                        // Right justify, Tacq = 20 uS, FOSC/16
    ADCON0bits.GO = 1;                                                          // initiate ADC conversion on the selected channel
    while (ADCON0bits.GO);                                                      // wait for conversion to finish (blocking)

    temp = ADRES / 5;                                                           // ADRES= 2mv / ADC step
                                                                                // temp = gr/C (including offset of 50)
    ADCON0 = 0b00000001;                                                        // ADC input AN0 (Pilot)
    ADCON1 = 0b00000000;                                                        // Use standard Voltage ref = VCC
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    TempEVSE = temp - 50;                                                       // set Temp (-50 to +125 deg C), and remove offset
}


void BlinkLed(void) {
    if (Error || ChargeDelay) {
        if (LedUpdate) {
            if (Error & (RCD_TRIPPED | CT_NOCOMM) ) {
                LedCount += 20;                                                 // Very rapid flashing, RCD tripped or no Serial Communication.
                if (LedCount > 128) LedPwm = ERROR_LED_BRIGHTNESS;              // LED 50% of time on, full brightness
                else LedPwm = 0;
            } else {                                                            // Waiting for Solar power or enough current to start charging
                LedCount += 2;                                                  // Slow blinking.
                if (LedCount > 230) LedPwm = WAITING_LED_BRIGHTNESS;            // LED 10% of time on, full brightness
                else LedPwm = 0;
            }

            LedUpdate = 0;
          }
    } else if (Access_bit == 0) LedPwm = 0;                                     // No Access, LED off
    else if (State == STATE_A) LedPwm = STATE_A_LED_BRIGHTNESS;                 // STATE A, LED on (dimmed)
    else if (State == STATE_B || State == STATE_B1) {
        LedPwm = STATE_B_LED_BRIGHTNESS;                                        // STATE B/B1, LED on (full brightness)
        LedCount = 128;                                                         // When switching to STATE C, start at full brightness
    } else if (State == STATE_C && LedUpdate)                                   // STATE C, LED fades in/out
    {
        if (Mode == MODE_SOLAR) LedCount ++;                                    // Slow fading (Solar mode)
        else LedCount += 2;                                                     // Faster fading (Smart mode)
        LedPwm = ease8InOutQuad(triwave8(LedCount));                            // pre calculate new LedPwm value
        LedUpdate = 0;
    }
}

void SetCurrent(unsigned int current)                                           // current in Amps*10 (160 = 16A)
{
    unsigned int DutyCycle;

    if ((current >= 60) && (current <= 510)) DutyCycle = (unsigned int) (current / 0.6);
                                                                                // calculate DutyCycle from current
    else if ((current > 510) && (current <= 800)) DutyCycle = (unsigned int) (current / 2.5) + 640;
    else DutyCycle = 100;                                                       // invalid, use 6A
    CCPR1L = DutyCycle >> 2;                                                    // Msb of DutyCycle
                                                                                // 2 Lsb are part of CCP1CON, use Timer 2
    CCP1CON = (((DutyCycle & 0x03) << 4) | 0x0C);                               // PWM Pilot signal enabled
}

/**
 * Get name of a state
 *
 * @param unsigned char State
 * @return unsigned char[] Name
 */
const unsigned char * getStateName(unsigned char StateCode) {
    if(StateCode < 11) return StrStateName[StateCode];
    else return "NOSTATE";
}

/**
 * Set EVSE mode
 * 
 * @param unsigned char Mode
 */
void setMode(unsigned char NewMode) {
    if (LoadBl == 1) ModbusWriteSingleRequest(BROADCAST_ADR, 0x0003, NewMode);
    if (NewMode == MODE_SMART) {
        Error &= ~(NO_SUN | LESS_6A);                                           // Clear All errors
        setSolarStopTimer(0);                                                   // Also make sure the SolarTimer is disabled.
    }
    ChargeDelay = 0;                                                            // Clear any Chargedelay
    BacklightTimer = BACKLIGHT;                                                 // Backlight ON
    Mode = NewMode;
}

/**
 * Set the solar stop timer
 * 
 * @param unsigned int Timer (seconds)
 */
void setSolarStopTimer(unsigned int Timer) {
    if (LoadBl == 1 && SolarStopTimer != Timer) {
        ModbusWriteSingleRequest(BROADCAST_ADR, 0x0004, Timer);
    }
    SolarStopTimer = Timer;
}

/**
 * Set state
 *
 * @param NewState
 */
void setState(unsigned char NewState) {
#ifdef LOG_INFO_EVSE
#ifndef LOG_DEBUG_EVSE
    if (State != NewState) {
#endif
        printf("\nSTATE %s->%s", getStateName(State), getStateName(NewState));
#ifndef LOG_DEBUG_EVSE
    }
#endif
#endif
    switch (NewState) {
        case STATE_B1:
            if (!ChargeDelay) ChargeDelay = 3;                                  // When entering State B1, wait at least 3 seconds before switching to another state.
            // fall through
        case STATE_A:                                                           // State A1
            CCP1CON = 0;                                                        // PWM off
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V (or +9V if connected to EV)
            CONTACTOR_OFF;                                                      // Contactor OFF
            if (NewState == STATE_A) {
                Error &= ~NO_SUN;
                Error &= ~LESS_6A;
                ChargeDelay = 0;                                                // Clear ChargeDelay when disconnected.
                // Reset Node
                Node[0].Timer = 0;
                Node[0].Phases = 0;
                Node[0].MinCurrent = 0;
            }
            break;
        case STATE_C:                                                           // State C2
            ActivationMode = 255;                                               // Disable ActivationMode
            DiodeCheck = 0;
            CONTACTOR_ON;                                                       // Contactor ON
            LCDTimer = 0;
            Timer = 0;                                                          // reset msTimer and ChargeTimer
            break;
        case STATE_C1:
            CCP1CON = 0;                                                        // PWM switched off, EV should detect and stop charging within 3 seconds
            C1Timer = 6;                                                        // Wait maximum 6 seconds, before forcing the contactor off.
            ChargeDelay = 15;
            break;
        default:
            break;
    }

    BalancedState[0] = NewState;
    State = NewState;

    BacklightTimer = BACKLIGHT;                                                 // Backlight ON
}

void setAccess(bool Access) {
    Access_bit = Access;
    if (!Access) {
        if (State == STATE_C) setState(STATE_C1);                               // tell EV to stop charging
        else if (State == STATE_B) setState(STATE_B1);                          // when not charging switch to State B1
    }
}

/**
 * Get serial number from flash
 *
 * @return unsigned int serialnr
 */
unsigned int getSerialNr(void) {
    unsigned int serialnr;

    EECON1 = 0x80;                                                              // Access Flash program memory

    TBLPTR = 0xFFF0;                                                            // set to serial nr.
    asm("TBLRD*+");
    serialnr = TABLAT;                                                          // first read LSB
    asm("TBLRD*+");
    serialnr |= TABLAT<<8;                                                      // then MSB

    return serialnr;
}

/**
 * Is there at least 6A (configurable MinCurrent) available for a EVSE?
 *
 * @param NodeNr
 * @return
 * returns 1 if there is 6A available
 * returns 0 if there is no current available
 */
char IsCurrentAvailable(unsigned char NodeNr) {
    unsigned char n, ActiveEVSE = 0;
    int Baseload, TotalCurrent = 0;


    for (n = 0; n < NR_EVSES; n++) if (BalancedState[n] == STATE_C)             // must be in STATE_C
    {
        ActiveEVSE++;                                                           // Count nr of active (charging) EVSE's
        TotalCurrent += Balanced[n];                                            // Calculate total max charge current for all active EVSE's
    }
    if (ActiveEVSE == 0) {                                                      // No active (charging) EVSE's
        if (Imeasured > ((MaxMains - MinCurrent) * 10)) {                       // There should be at least 6A available
            return 0;                                                           // Not enough current available!, return with error
        }
    } else {                                                                    // at least one active EVSE
        ActiveEVSE++;                                                           // Do calculations with one more EVSE
        Baseload = Imeasured - TotalCurrent;                                    // Calculate Baseload (load without any active EVSE)
        if (Baseload < 0) Baseload = 0;                                         // only relevant for Smart/Solar mode

        if (ActiveEVSE > NR_EVSES) ActiveEVSE = NR_EVSES;
        // When load balancing is active, and we are the Master, the Circuit option limits the max total current
        if (LoadBl == 1) {
            if ((ActiveEVSE * (MinCurrent * 10)) > (MaxCircuit * 10)) {
                return 0;                                                       // Not enough current available!, return with error
            }
        }

        // Check if the lowest charge current(6A) x ActiveEV's + baseload would be higher then the MaxMains.
        if ((ActiveEVSE * (MinCurrent * 10) + Baseload) > (MaxMains * 10)) {
            return 0;                                                           // Not enough current available!, return with error
        }

    }

    // Allow solar Charging if surplus current is above 'StartCurrent' (sum of all phases)
    // Charging will start after the timeout (chargedelay) period has ended
    // Only when StartCurrent configured or Node MinCurrent detected or Node inactive
    if (Mode == MODE_SOLAR && (StartCurrent || Node[NodeNr].MinCurrent || BalancedState[NodeNr] == STATE_A)) {
        // no active EVSE yet?
        if (ActiveEVSE == 0) {
            if (StartCurrent == 0) {
                if (Isum >= ((signed int)Node[NodeNr].MinCurrent *-1) + (signed int)(ImportCurrent * 10)) return 0;
            } else {
                if (Isum >= ((signed int)StartCurrent *-10)) return 0;
            }
        }
        // check if we can split the available current between all active EVSE's
        else if ((ActiveEVSE * MinCurrent * 10) > TotalCurrent) return 0;
    }

    return 1;
}

void ResetBalancedStates(void) {
    unsigned char n;

    for (n = 1; n < NR_EVSES; n++) {
        BalancedState[n] = STATE_A;                                             // Yes, disable old active Node states
        Balanced[n] = 0;                                                        // reset ChargeCurrent to 0
    }
}

// Calculates Balanced PWM current for each EVSE
// mod =0 normal
// mod =1 we have a new EVSE requesting to start charging.
//
void CalcBalancedCurrent(char mod) {
    int Average, MaxBalanced, Idifference;
    int BalancedLeft = 0;
    signed int IsumImport;
    int ActiveMax = 0, TotalCurrent = 0, Baseload;
    char CurrentSet[NR_EVSES] = {0, 0, 0, 0, 0, 0, 0, 0};
    char n;

    if (!LoadBl) ResetBalancedStates();                                         // Load balancing disabled?, Reset States
                                                                                // Do not modify MaxCurrent as it is a config setting. (fix 2.05)
    if (BalancedState[0] == STATE_C && MaxCurrent > MaxCapacity && !Config) ChargeCurrent = MaxCapacity * 10;
    else ChargeCurrent = MaxCurrent * 10;                                       // Instead use new variable ChargeCurrent.

    // Override current temporary if set (from Modbus)
    if (OverrideCurrent) ChargeCurrent = OverrideCurrent;

    if (LoadBl < 2) BalancedMax[0] = ChargeCurrent;                             // Load Balancing Disabled or Master:
                                                                                // update BalancedMax[0] if the MAX current was adjusted using buttons or CLI

    for (n = 0; n < NR_EVSES; n++) if (BalancedState[n] == STATE_C) {
            BalancedLeft++;                                                     // Count nr of Active (Charging) EVSE's
            ActiveMax += BalancedMax[n];                                        // Calculate total Max Amps for all active EVSEs
            TotalCurrent += Balanced[n];                                        // Calculate total of all set charge currents
        }

    if (!mod && Mode != MODE_SOLAR) {                                           // Normal and Smart mode
        Idifference = (MaxMains * 10) - Imeasured;                              // Difference between MaxMains and Measured current (can be negative)

        if (Idifference > 0) IsetBalanced += (Idifference / 4);                 // increase with 1/4th of difference (slowly increase current)
        else IsetBalanced += (Idifference * 100 / TRANSFORMER_COMP);            // last PWM setting + difference (immediately decrease current)
        if (IsetBalanced < 0) IsetBalanced = 0;
        if (IsetBalanced > 800) IsetBalanced = 800;                             // hard limit 80A (added 11-11-2017)
    }



    if (Mode == MODE_SOLAR)                                                     // Solar version
    {
#ifdef SPECIAL
        ImportCurrent = 0;                                                      // Import option not visible , make sure it's set to 0
#endif
#ifdef IMPORTCURRENT_ALWAYS
        IsumImport = Isum - (signed int)(ImportCurrent * 10);                   // Allow Import of power from the grid when solar charging
#else
        IsumImport = Isum;
#endif

        if (IsumImport < 0) {
            // negative, we have surplus (solar) power available
            if (IsumImport < -10) IsetBalanced = IsetBalanced + 5;              // more then 1A available, increase Balanced charge current with 0.5A
            else IsetBalanced = IsetBalanced + 1;                               // less then 1A available, increase with 0.1A
        } else {
            // positive, we use more power then is generated
            if (IsumImport > 20) IsetBalanced = IsetBalanced - (IsumImport / 2);// we use atleast 2A more then available, decrease Balanced charge current.
            else if (IsumImport > 10) IsetBalanced = IsetBalanced - 5;          // we use 1A more then available, decrease with 0.5A
            else if (IsumImport > 3) IsetBalanced = IsetBalanced - 1;           // we use < 1A more then available, decrease with 0.1A
        }

        // If IsetBalanced is below MinCurrent or negative, make sure it's set to MinCurrent.
        if ( (IsetBalanced < (BalancedLeft * MinCurrent * 10)) || (IsetBalanced < 0) ) {
            IsetBalanced = BalancedLeft * MinCurrent * 10;
                                                                                // ----------- Check to see if we have to continue charging on solar power alone ----------
#ifdef IMPORTCURRENT_ALWAYS
            if (BalancedLeft && StopTime && (IsumImport > 10)) {
#else
            if (BalancedLeft && StopTime && ((Isum - (signed int)(ImportCurrent * 10)) > 10)) {
#endif
                if (SolarStopTimer == 0) setSolarStopTimer(StopTime * 60);      // Convert minutes into seconds
            } else {
                setSolarStopTimer(0);
            }
        } else {
            setSolarStopTimer(0);
        }
    }
                                                                                // When Load balancing = Master,  Limit total current of all EVSEs to MaxCircuit
    if (LoadBl == 1 && (IsetBalanced > (MaxCircuit * 10)) ) IsetBalanced = MaxCircuit * 10;


    Baseload = Imeasured - TotalCurrent;                                        // Calculate Baseload (load without any active EVSE)
    if (Baseload < 0) Baseload = 0;

    if (Mode == MODE_NORMAL)                                                    // Normal Mode
    {
        if (LoadBl == 1) IsetBalanced = MaxCircuit * 10;                        // Load Balancing = Master? MaxCircuit is max current for all active EVSE's
        else IsetBalanced = ChargeCurrent;                                      // No Load Balancing in Normal Mode. Set current to ChargeCurrent (fix: v2.05)
    }

    if (BalancedLeft)                                                           // Only if we have active EVSE's
    {
        // New EVSE charging, and no Solar mode
        if (mod && Mode != MODE_SOLAR) IsetBalanced = (MaxMains * 10) - Baseload;// Set max combined charge current to MaxMains - Baseload

        if (IsetBalanced < 0 || IsetBalanced < (BalancedLeft * MinCurrent * 10)
          || ( Mode == MODE_SOLAR && Isum > 10 && Imeasured > (MaxMains * 10)) )
        {
            IsetBalanced = BalancedLeft * MinCurrent * 10;                      // set minimal "MinCurrent" charge per active EVSE
            NoCurrent++;                                                        // Flag NoCurrent left
#ifdef LOG_INFO_EVSE
            printf("\nNo Current!!");
#endif
        } else NoCurrent = 0;

        if (IsetBalanced > ActiveMax) IsetBalanced = ActiveMax;                 // limit to total maximum Amps (of all active EVSE's)

        MaxBalanced = IsetBalanced;                                             // convert to Amps

        // Automatic StartCurrent detection
        if (StartCurrent == 0) {
            for (n = 0; n < NR_EVSES; n++) {
                if(BalancedState[n] == STATE_C && !Node[n].MinCurrent) {
                    if(SolarStopTimer && SolarStopTimer < 10) setSolarStopTimer(SolarStopTimer + 60);
                    if(Node[n].Timer >= STARTCURRENT_AUTO_TIMER) {
                        if (Node[n].EVMeter) {
                            // Request EV current measurement
                            EVMeasureNode = n;
                        } else if(!CMMeasureTimer) {
                            CMMeasureNode = n;
                            CMMeasureTimer = 12 * 3 + 4 + 1;
                        }
                    }
                    if (Node[n].EVMeter || CMMeasured) {
                        Balanced[n] = MinCurrent * 10;
                    } else {
                        Balanced[n] = (MinCurrent + 2) * 10;
                    }
                    CurrentSet[n] = true;                                       // mark this EVSE as set.
                    BalancedLeft--;                                             // decrease counter of active EVSE's
                    MaxBalanced -= Balanced[n];                                 // Update total current to new (lower) value
                }
            }
        }

        // Calculate average current per EVSE
        n = 0;
        do {
            Average = MaxBalanced / BalancedLeft;                               // Average current for all active EVSE's

        // Check for EVSE's that have a lower MAX current
            if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]) && (Average >= BalancedMax[n])) // Active EVSE, and current not yet calculated?
            {
                Balanced[n] = BalancedMax[n];                                   // Set current to Maximum allowed for this EVSE
                CurrentSet[n] = 1;                                              // mark this EVSE as set.
                BalancedLeft--;                                                 // decrease counter of active EVSE's
                MaxBalanced -= Balanced[n];                                     // Update total current to new (lower) value
                n = 0;                                                          // check all EVSE's again
            } else n++;
        } while (n < NR_EVSES && BalancedLeft);

        // All EVSE's which had a Max current lower then the average are set.
        // Now calculate the current for the EVSE's which had a higher Max current
        n = 0;
        if (BalancedLeft)                                                       // Any Active EVSE's left?
        {
            do {                                                                // Check for EVSE's that are not set yet
                if ((BalancedState[n] == STATE_C) && (!CurrentSet[n]))          // Active EVSE, and current not yet calculated?
                {
                    Balanced[n] = MaxBalanced / BalancedLeft;                   // Set current to Average
                    CurrentSet[n] = 1;                                          // mark this EVSE as set.
                    BalancedLeft--;                                             // decrease counter of active EVSE's
                    MaxBalanced -= Balanced[n];                                 // Update total current to new (lower) value
                }
            } while (++n < NR_EVSES && BalancedLeft);
        }


    } // BalancedLeft

#ifdef LOG_DEBUG_EVSE
    if (LoadBl == 1) {
        printf("\nBalance:");
        for (n = 0; n < NR_EVSES; n++) {
            printf("EVSE%u:%s(%u.%1uA)", n, getStateName(BalancedState[n]), Balanced[n]/10, Balanced[n]%10);
            if (n < NR_EVSES-1) printf(",");
        }
    }
#endif
}

/**
 * Broadcast momentary currents to all Node EVSE's
 */
void BroadcastCurrent(void) {
    ModbusWriteMultipleRequest(BROADCAST_ADR, 0x0020, Balanced, NR_EVSES);
}

/**
 * Master requests Node configuration over modbus
 * Master -> Node
 * 
 * @param unsigned char NodeNr (1-7)
 */
void requestNodeConfig(unsigned char NodeNr) {
    ModbusReadInputRequest(NodeNr + 1u, 4, 0x0108, 2);
}

/**
 * Master receives Node configuration over modbus
 * Node -> Master
 * 
 * @param unsigned char NodeNr (1-7)
 */
void receiveNodeConfig(unsigned char *buf, unsigned char NodeNr) {
    Node[NodeNr].EVMeter = buf[1];
    Node[NodeNr].EVAddress = buf[3];

    Node[NodeNr].ConfigChanged = 0;                                             // Reset flag on master
    ModbusWriteSingleRequest(NodeNr + 1u, 0x0006, 0);                           // Reset flag on node
}

/**
 * Master requests Node status over modbus
 * Master -> Node
 *
 * @param unsigned char NodeNr (1-7)
 */
void requestNodeStatus(unsigned char NodeNr) {
    Node[NodeNr].Online = false;
    ModbusReadInputRequest(NodeNr + 1u, 4, 0x0000, 8);
}

/**
 * Master receives Node status over modbus
 * Node -> Master
 *
 * @param unsigned char NodeAdr (1-7)
 */
void receiveNodeStatus(unsigned char *buf, unsigned char NodeNr) {
    Node[NodeNr].Online = true;
//    memcpy(buf, (unsigned char*)&Node[NodeNr], sizeof(struct NodeState));
    BalancedState[NodeNr] = buf[1];                                             // Node State
    BalancedError[NodeNr] = buf[3];                                             // Node Error status
    // Update Mode when changed on Node and not Smart/Solar Switch on the Master
    // Also make sure we are not in the menu.
    if (buf[7] != Mode && (buf[7] == MODE_SMART || buf[7] == MODE_SOLAR) && Switch != SMART_SOLAR_SWITCH && !LCDNav) setMode(buf[7]);
    Node[NodeNr].ConfigChanged = buf[13] | Node[NodeNr].ConfigChanged;
    BalancedMax[NodeNr] = buf[15] * 10;                                         // Node Max ChargeCurrent (0.1A)
    //printf("\nReceivedNode[%u]Status State:%u Error:%u, BalancedMax:%u ", NodeNr, BalancedState[NodeNr], BalancedError[NodeNr], BalancedMax[NodeNr] );
}

/**
 * Master checks node status requests, and responds with new state
 * Master -> Node
 *
 * @param unsigned char NodeAdr (1-7)
 */
void processAllNodeStates(unsigned char NodeNr) {
    unsigned int values[2];
    unsigned char current, write = 0;

    values[0] = BalancedState[NodeNr];

    current = IsCurrentAvailable(NodeNr);
    if (current) {                                                              // Yes enough current
        if (BalancedError[NodeNr] & (LESS_6A|NO_SUN)) {
            BalancedError[NodeNr] &= ~(LESS_6A | NO_SUN);                       // Clear Error flags
            write = 1;
        }
    }

    // Check EVSE for request to charge states
    switch (BalancedState[NodeNr]) {
        case STATE_A:
            // Reset Node
            Node[NodeNr].Timer = 0;
            Node[NodeNr].Phases = 0;
            Node[NodeNr].MinCurrent = 0;
            break;

        case STATE_COMM_B:                                                      // Request to charge A->B
#ifdef LOG_INFO_EVSE
            printf("\nNode %u State A->B request ", NodeNr);
#endif
            if (current) {                                                      // check if we have enough current
                                                                                // Yes enough current..
                BalancedState[NodeNr] = STATE_B;                                // Mark Node EVSE as active (State B)
                Balanced[NodeNr] = MinCurrent * 10;                             // Initially set current to lowest setting
                values[0] = STATE_COMM_B_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!");
#endif
            } else {                                                            // We do not have enough current to start charging
                Balanced[NodeNr] = 0;                                           // Make sure the Node does not start charging by setting current to 0
                if ((BalancedError[NodeNr] & (LESS_6A|NO_SUN)) == 0) {          // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[NodeNr] |= NO_SUN;    // Solar mode: No Solar Power available
                    else BalancedError[NodeNr] |= LESS_6A;                      // Normal or Smart Mode: Not enough current available
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!");
#endif
            }
            break;

        case STATE_COMM_C:                                                      // request to charge B->C
#ifdef LOG_INFO_EVSE
            printf("\nNode %u State B->C request ", NodeNr);
#endif
            Balanced[NodeNr] = 0;                                               // For correct baseload calculation set current to zero
            if (current) {                                                      // check if we have enough current
                                                                                // Yes
                BalancedState[NodeNr] = STATE_C;                                // Mark Node EVSE as Charging (State C)
                CalcBalancedCurrent(1);                                         // Calculate charge current for all connected EVSE's
                values[0] = STATE_COMM_C_OK;
                write = 1;
#ifdef LOG_INFO_EVSE
                printf("- OK!");
#endif
            } else {                                                            // We do not have enough current to start charging
                if ((BalancedError[NodeNr] & (LESS_6A|NO_SUN)) == 0) {          // Error flags cleared?
                    if (Mode == MODE_SOLAR) BalancedError[NodeNr] |= NO_SUN;    // Solar mode: No Solar Power available
                    else BalancedError[NodeNr] |= LESS_6A;                      // Normal or Smart Mode: Not enough current available
                    write = 1;
                }
#ifdef LOG_INFO_EVSE
                printf("- Not enough current!");
#endif
            }
            break;

        default:
            break;

    }
    values[1] = BalancedError[NodeNr];

    if (write) {
#ifdef LOG_DEBUG_EVSE
        printf("\nNodeAdr %u, BalancedError:%u",NodeNr, BalancedError[NodeNr]);
#endif
        ModbusWriteMultipleRequest(NodeNr+1 , 0x0000, values, 2);               // Write State and Error to Node
    }

}


/**
 * Create an array of available menu items
 * Depends on configuration settings like CONFIG/MODE/LoadBL
 *
 * @return unsigned char MenuItemCount
 */
unsigned char getMenuItems (void) {
    unsigned char m = 0;

    MenuItems[m++] = MENU_CONFIG;                                               // Configuration (0:Socket / 1:Fixed Cable)
    if (!Config) {                                                              // ? Fixed Cable?
        MenuItems[m++] = MENU_LOCK;                                             // - Cable lock (0:Disable / 1:Solenoid / 2:Motor)
    }
    MenuItems[m++] = MENU_MODE;                                                 // EVSE mode (0:Normal / 1:Smart)
    if (Mode == MODE_SOLAR && LoadBl < 2) {                                     // ? Solar mode and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_START;                                            // - Start Surplus Current (A)
        MenuItems[m++] = MENU_STOP;                                             // - Stop time (min)
        #ifndef SPECIAL
        MenuItems[m++] = MENU_IMPORT;                                           // - Import Current from Grid (A)
        #endif
    }
    MenuItems[m++] = MENU_LOADBL;                                               // Load Balance Setting (0:Disable / 1:Master / 2-8:Node)
    if (Mode && LoadBl < 2) {                                                   // ? Mode Smart/Solar and Load Balancing Disabled/Master?
        MenuItems[m++] = MENU_MAINS;                                            // - Max Mains Amps (hard limit, limited by the MAINS connection) (A) (Mode:Smart/Solar)
    }
    if (Mode && LoadBl < 2 || LoadBl == 1) {                                    // ? Mode Smart/Solar or LoadBl Master?
        MenuItems[m++] = MENU_MIN;                                              // - Minimal current the EV is happy with (A) (Mode:Smart/Solar or LoadBl:Master)
    }
    if (LoadBl == 1) {                                                          // ? Load balancing Master?
        MenuItems[m++] = MENU_CIRCUIT;                                          // - Max current of the EVSE circuit (A) (LoadBl:Master)
    }
    MenuItems[m++] = MENU_MAX;                                                  // Max Charge current (A)
    MenuItems[m++] = MENU_SWITCH;                                               // External Switch on SW (0:Disable / 1:Access / 2:Smart-Solar)
    MenuItems[m++] = MENU_RCMON;                                                // Residual Current Monitor on RCM (0:Disable / 1:Enable)
    MenuItems[m++] = MENU_RFIDREADER;                                           // RFID Reader connected to SW (0:Disable / 1:EnableAll / 2:EnableOne / 3:Learn / 4:Delete / 5:Delete All)
    if (Mode) {                                                                 // ? Smart or Solar mode?
        if (LoadBl < 2) {                                                       // - ? Load Balancing Disabled/Master?
            MenuItems[m++] = MENU_MAINSMETER;                                   // - - Type of Mains electric meter (0: Disabled / Constants EM_*)
            if (MainsMeter == EM_SENSORBOX) {                                   // - - ? Sensorbox?
                #ifndef SPECIAL
                if (GridActive == 1) MenuItems[m++] = MENU_GRID;
                #endif
                if (CalActive == 1) MenuItems[m++] = MENU_CAL;                  // - - - Sensorbox CT measurement calibration
            } else if(MainsMeter) {                                             // - - ? Other?
                MenuItems[m++] = MENU_MAINSMETERADDRESS;                        // - - - Address of Mains electric meter (5 - 254)
                MenuItems[m++] = MENU_MAINSMETERMEASURE;                        // - - - What does Mains electric meter measure (0: Mains (Home+EVSE+PV) / 1: Home+EVSE / 2: Home)
                if (MainsMeterMeasure) {                                        // - - - ? PV not measured by Mains electric meter?
                    MenuItems[m++] = MENU_PVMETER;                              // - - - - Type of PV electric meter (0: Disabled / Constants EM_*)
                    if (PVMeter) MenuItems[m++] = MENU_PVMETERADDRESS;          // - - - - - Address of PV electric meter (5 - 254)
                }
            }
        }
        MenuItems[m++] = MENU_EVMETER;                                          // - Type of EV electric meter (0: Disabled / Constants EM_*)
        if (EVMeter) {                                                          // - ? EV meter configured?
            MenuItems[m++] = MENU_EVMETERADDRESS;                               // - - Address of EV electric meter (5 - 254)
        }
        if (LoadBl < 2) {                                                       // - ? Load Balancing Disabled/Master?
            if (MainsMeter == EM_CUSTOM || PVMeter == EM_CUSTOM || EVMeter == EM_CUSTOM) { // ? Custom electric meter used?
                MenuItems[m++] = MENU_EMCUSTOM_ENDIANESS;                       // - - Byte order of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_DATATYPE;                        // - - Data type of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_FUNCTION;                        // - - Modbus Function of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_UREGISTER;                       // - - Starting register for voltage of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_UDIVISOR;                        // - - Divisor for voltage of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_IREGISTER;                       // - - Starting register for current of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_IDIVISOR;                        // - - Divisor for current of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_PREGISTER;                       // - - Starting register for power of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_PDIVISOR;                        // - - Divisor for power of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_EREGISTER;                       // - - Starting register for energy of custom electric meter
                MenuItems[m++] = MENU_EMCUSTOM_EDIVISOR;                        // - - Divisor for energy of custom electric meter
            }
        }
    }
    if (MainsMeter == EM_SENSORBOX && SB2SoftwareVer >= 0x01) {
        MenuItems[m++] = MENU_WIFI;                                             // Wifi Disabled / Enabled / Portal
    }
    MenuItems[m++] = MENU_EXIT;

    return m;
}

/**
 * Check minimum and maximum of a value and set the variable
 *
 * @param unsigned char MENU_xxx
 * @param unsigned int value
 * @return unsigned char success
 */
unsigned char setItemValue(unsigned char nav, unsigned int val) {
    if (nav < MENU_EXIT) {
        if (val < MenuStr[nav].Min || val > MenuStr[nav].Max) return 0;
    }

    switch (nav) {
        case MENU_CONFIG:
            Config = val;
            break;
        case STATUS_MODE:
            // Do not change Charge Mode when set to Normal or Load Balancing is disabled
            if (Mode == 0 || LoadBl == 0) break;
        case MENU_MODE:
            Mode = val;
            break;
        case MENU_START:
            StartCurrent = val;
            break;
        case MENU_STOP:
            StopTime = val;
            break;
        case MENU_IMPORT:
            ImportCurrent = val;
            break;
        case MENU_LOADBL:
            LoadBl = val;
            break;
        case MENU_MAINS:
            MaxMains = val;
            break;
        case MENU_MIN:
            MinCurrent = val;
            break;
        case MENU_MAX:
            MaxCurrent = val;
            break;
        case MENU_CIRCUIT:
            MaxCircuit = val;
            break;
        case MENU_LOCK:
            Lock = val;
            break;
        case MENU_SWITCH:
            Switch = val;
            break;
        case MENU_RCMON:
            RCmon = val;
            break;
        case MENU_CAL:
            ICal = val;
            break;
        case MENU_GRID:
            Grid = val;
            break;
        case MENU_MAINSMETER:
            MainsMeter = val;
            break;
        case MENU_MAINSMETERADDRESS:
            MainsMeterAddress = val;
            break;
        case MENU_MAINSMETERMEASURE:
            MainsMeterMeasure = val;
            break;
        case MENU_PVMETER:
            PVMeter = val;
            break;
        case MENU_PVMETERADDRESS:
            PVMeterAddress = val;
            break;
        case MENU_EVMETER:
            EVMeter = val;
            break;
        case MENU_EVMETERADDRESS:
            EVMeterAddress = val;
            break;
        case MENU_EMCUSTOM_ENDIANESS:
            EMConfig[EM_CUSTOM].Endianness = val;
            break;
        case MENU_EMCUSTOM_DATATYPE:
            EMConfig[EM_CUSTOM].DataType = val;
            break;
        case MENU_EMCUSTOM_FUNCTION:
            EMConfig[EM_CUSTOM].Function = val;
            break;
        case MENU_EMCUSTOM_UREGISTER:
            EMConfig[EM_CUSTOM].URegister = val;
            break;
        case MENU_EMCUSTOM_UDIVISOR:
            EMConfig[EM_CUSTOM].UDivisor = val;
            break;
        case MENU_EMCUSTOM_IREGISTER:
            EMConfig[EM_CUSTOM].IRegister = val;
            break;
        case MENU_EMCUSTOM_IDIVISOR:
            EMConfig[EM_CUSTOM].IDivisor = val;
            break;
        case MENU_EMCUSTOM_PREGISTER:
            EMConfig[EM_CUSTOM].PRegister = val;
            break;
        case MENU_EMCUSTOM_PDIVISOR:
            EMConfig[EM_CUSTOM].PDivisor = val;
            break;
        case MENU_EMCUSTOM_EREGISTER:
            EMConfig[EM_CUSTOM].ERegister = val;
            break;
        case MENU_EMCUSTOM_EDIVISOR:
            EMConfig[EM_CUSTOM].EDivisor = val;
            break;
        case MENU_RFIDREADER:
            RFIDReader = val;
            break;
        case MENU_WIFI:
            WIFImode = val;
            break;

        // Status writeable
        case STATUS_STATE:
            setState(val);
            break;
        case STATUS_ERROR:
            Error = val;
            if (Error) {                                                        // Is there an actual Error? Maybe the error got cleared?
                if (State == STATE_C) setState(STATE_C1);                       // tell EV to stop charging
                else setState(STATE_B1);                                        // when we are not charging switch to State B1
                ChargeDelay = CHARGEDELAY;
#ifdef LOG_DEBUG_MODBUS
                printf("\nBroadcast Error message received!");
            } else {
                printf("\nBroadcast Errors Cleared received!");
#endif
            }
            break;
        case STATUS_CURRENT:
            OverrideCurrent = val;
            break;
        case STATUS_SOLAR_TIMER:
            setSolarStopTimer(val);
            break;
        case STATUS_ACCESS:
            if (val == 0 || val == 1) {
                setAccess(val);
            }
            break;
        case STATUS_CONFIG_CHANGED:
            ConfigChanged = val;
            break;

        default:
            return 0;
    }

    return 1;
}

/**
 * Get the variable
 *
 * @param unsigned char MENU_xxx
 * @return unsigned int value
 */
unsigned int getItemValue(unsigned char nav) {
    switch (nav) {
        case MENU_CONFIG:
            return Config;
        case MENU_MODE:
        case STATUS_MODE:
            return Mode;
        case MENU_START:
            return StartCurrent;
        case MENU_STOP:
            return StopTime;
        case MENU_IMPORT:
            return ImportCurrent;
        case MENU_LOADBL:
            return LoadBl;
        case MENU_MAINS:
            return MaxMains;
        case MENU_MIN:
            return MinCurrent;
        case MENU_MAX:
            return MaxCurrent;
        case MENU_CIRCUIT:
            return MaxCircuit;
        case MENU_LOCK:
            return Lock;
        case MENU_SWITCH:
            return Switch;
        case MENU_RCMON:
            return RCmon;
        case MENU_CAL:
            return ICal;
        case MENU_GRID:
            return Grid;
        case MENU_MAINSMETER:
            return MainsMeter;
        case MENU_MAINSMETERADDRESS:
            return MainsMeterAddress;
        case MENU_MAINSMETERMEASURE:
            return MainsMeterMeasure;
        case MENU_PVMETER:
            return PVMeter;
        case MENU_PVMETERADDRESS:
            return PVMeterAddress;
        case MENU_EVMETER:
            return EVMeter;
        case MENU_EVMETERADDRESS:
            return EVMeterAddress;
        case MENU_EMCUSTOM_ENDIANESS:
            return EMConfig[EM_CUSTOM].Endianness;
        case MENU_EMCUSTOM_DATATYPE:
            return (unsigned int)EMConfig[EM_CUSTOM].DataType;
        case MENU_EMCUSTOM_FUNCTION:
            return EMConfig[EM_CUSTOM].Function;
        case MENU_EMCUSTOM_UREGISTER:
            return EMConfig[EM_CUSTOM].URegister;
        case MENU_EMCUSTOM_UDIVISOR:
            return EMConfig[EM_CUSTOM].UDivisor;
        case MENU_EMCUSTOM_IREGISTER:
            return EMConfig[EM_CUSTOM].IRegister;
        case MENU_EMCUSTOM_IDIVISOR:
            return EMConfig[EM_CUSTOM].IDivisor;
        case MENU_EMCUSTOM_PREGISTER:
            return EMConfig[EM_CUSTOM].PRegister;
        case MENU_EMCUSTOM_PDIVISOR:
            return EMConfig[EM_CUSTOM].PDivisor;
        case MENU_EMCUSTOM_EREGISTER:
            return EMConfig[EM_CUSTOM].ERegister;
        case MENU_EMCUSTOM_EDIVISOR:
            return EMConfig[EM_CUSTOM].EDivisor;
        case MENU_RFIDREADER:
            return RFIDReader;
        case MENU_WIFI:
            return WIFImode;

        // Status writeable
        case STATUS_STATE:
            return State;
        case STATUS_ERROR:
            return Error;
        case STATUS_CURRENT:
            return Balanced[0];
        case STATUS_SOLAR_TIMER:
            return SolarStopTimer;
        case STATUS_ACCESS:
            return Access_bit;
        case STATUS_CONFIG_CHANGED:
            return ConfigChanged;

        // Status readonly
        case STATUS_MAX:
            return MaxCapacity;
        case STATUS_PHASE_COUNT:
            return Node[0].Phases;
        case STATUS_TEMP:
            return (unsigned int)((signed int)TempEVSE + 273);
        case STATUS_SERIAL:
            return serialnr;

        default:
            return 0;
    }
}

/**
 * Get active option of an menu item
 *
 * @param unsigned char nav
 * @return unsigned char[] MenuItemOption
 */
const char * getMenuItemOption(unsigned char nav) {
    static unsigned char Str[10]; // must be declared static, since it's referenced outside of function scope
    unsigned int value;

    value = getItemValue(nav);

    switch (nav) {
        case MENU_CONFIG:
            if (Config) return StrFixed;
            else return StrSocket;
        case MENU_MODE:
            if (Mode == MODE_SMART) return StrSmart;
            else if (Mode == MODE_SOLAR) return StrSolar;
            else return StrNormal;
        case MENU_START:
                if (value == 0) return "Automatic";
                else sprintf(Str, "-%2u A", value);
                return Str;
        case MENU_STOP:
            if (value) {
                sprintf(Str, "%2u min", value);
                return Str;
            } else return StrDisabled;
        case MENU_LOADBL:
            if (ExternalMaster && value == 1) return "Node 0";
            else return StrLoadBl[LoadBl];
        case MENU_MAINS:
        case MENU_MIN:
        case MENU_MAX:
        case MENU_CIRCUIT:
        case MENU_IMPORT:
            sprintf(Str, "%2u A", value);
            return Str;
        case MENU_LOCK:
            if (Lock == 1) return StrSolenoid;
            else if (Lock == 2) return StrMotor;
            else return StrDisabled;
        case MENU_SWITCH:
            return StrSwitch[Switch];
        case MENU_RCMON:
            if (RCmon) return StrEnabled;
            else return StrDisabled;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:
            return EMConfig[value].Desc;
        case MENU_GRID:
            return StrGrid[Grid];
        case MENU_MAINSMETERADDRESS:
        case MENU_PVMETERADDRESS:
        case MENU_EVMETERADDRESS:
        case MENU_EMCUSTOM_UREGISTER:
        case MENU_EMCUSTOM_IREGISTER:
        case MENU_EMCUSTOM_PREGISTER:
        case MENU_EMCUSTOM_EREGISTER:
            if(value < 0x1000) sprintf(Str, "%u (%02X)", value, value);
            else sprintf(Str, "%u %X", value, value);
            return Str;
        case MENU_MAINSMETERMEASURE:
            if (MainsMeterMeasure) return StrMainsHomeEVSE;
            else return StrMainsAll;
        case MENU_EMCUSTOM_ENDIANESS:
            switch(value) {
                case 0: return "LBF & LWF";
                case 1: return "LBF & HWF";
                case 2: return "HBF & LWF";
                case 3: return "HBF & HWF";
            }
        case MENU_EMCUSTOM_DATATYPE:
            switch (value) {
                case MB_DATATYPE_INT16: return "INT16";
                case MB_DATATYPE_INT32: return "INT32";
                case MB_DATATYPE_FLOAT32: return "FLOAT32";
            }
        case MENU_EMCUSTOM_FUNCTION:
            switch (value) {
                case 3: return "3:Hold.Reg";
                case 4: return "4:InputReg";
            }
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            sprintf(Str, "%lu", pow10[value]);
            return Str;
        case MENU_RFIDREADER:
            return StrRFIDReader[RFIDReader];
        case MENU_WIFI:
            return StrWiFi[WIFImode];
        case MENU_EXIT:
            return StrExitMenu;
        default:
            return "";
    }
}

// Serial Command line interface
// Display Menu, and process input.
//------------------------------------------------
// Smart EVSE
// -- Main menu --
// CONFIG - Set to Fixed Cable or Type 2 Socket
// MODE   - Set to Normal, Smart or Solar EVSE mode
// START  - Surplus energy start Current
// STOP   - Stop solar charging at 6A after this time
// LOADBL - Set Load Balancing to Disabled, Master or Node1-3
// MAINS  - Set max MAINS Current (25-100)
// MAX    - Set MAX Charge Current for the EV (16-80)
// MIN    - Set MIN Charge Current the EV will accept
// CAL    - Calibrate CT1
// LOCK   - Cable lock Disable/Solenoid/Motor
// ACCESS - Access control on IO2
// RCMON  - Residual Current Monitor on IO3
// L1: 1.2A L2: 5.3A L3: 0.4A (MAX:26A MIN:10A)
//

void RS232cli(void) {
    unsigned char i, OK, x;
    unsigned int n;
    unsigned int Inew;                                                          // resolution 0.1A
    unsigned char MenuItemsCount = getMenuItems();

    printf("\n");
    if (menu == 0)                                                              // menu = Main Menu
    {
        for(i = 0; i < MenuItemsCount - 1; i++) {
            if (strcmp(U2buffer, MenuStr[MenuItems[i]].Key) == 0) menu = MenuItems[i];
        }
        if (strcmp(U2buffer, (const char *) "STATE?") == 0 ) {                  // request charging state for all connected EVSE's
            menu = MENU_STATE;
        }
    } else if (U2buffer[0] == 0) menu = 0;
    else {
        switch (menu) {
            case MENU_CAL:
                x = 0;
                do {                                                            // remove decimal point from string
                    i = U2buffer[x];                                            // so 23.5 becomes 235
                    if (i == '.') {
                        U2buffer[x] = U2buffer[x + 1u];
                        U2buffer[x + 1u] = '\0';
                    }
                    x++;
                } while (i != '\0');

                Inew = atoi(U2buffer);
                if ((Inew < 60) || (Inew > 800)) printf("\nError! please calibrate with at least 6A\n");
                else {
                    ICal = ((unsigned long)Inew * 10 + 5) * ICAL / Iuncal;      // Calculate new Calibration value
                    write_settings();
                }
                break;
            case MENU_MODE:
                if (strcmp(U2buffer, (const char *) "SOLAR") == 0) {
                    Mode = MODE_SOLAR;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "SMART") == 0) {
                    Mode = MODE_SMART;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "NORMAL") == 0) {
                    Mode = MODE_NORMAL;
                    write_settings();
                    Error = NO_ERROR; // Clear Errors
                }
                break;
            case MENU_LOCK:
                if (strcmp(U2buffer, (const char *) "SOLENOID") == 0) {
                    Lock = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "MOTOR") == 0) {
                    Lock = 2;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "DISABLE") == 0) {
                    Lock = 0;
                    write_settings();
                }
                break;
            case MENU_CONFIG:
                if (strcmp(U2buffer, (const char *) "FIXED") == 0) {
                    Config = 1;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "SOCKET") == 0) {
                    Config = 0;
                    write_settings();
                }
                break;
            case MENU_LOADBL:
                for(i = 0; i <= NR_EVSES; i++){
                    if (strcmp(U2buffer, StrLoadBl[i]) == 0) {
                        LoadBl = i;
                        write_settings();
                    }
                }
                break;
            case MENU_SWITCH:
                for(i = 0; i < 5; i++){
                    if (strcmp(U2buffer, StrSwitch[i]) == 0) {
                        Switch = i;
                        write_settings();
                    }
                }
                break;
            case MENU_GRID:
                for(i = 0; i < 2; i++){
                    if (strcmp(U2buffer, StrGrid[i]) == 0) {
                        Grid = i;                                               // 4Wire=0, 3Wire=1
                        write_settings();
                    }
                }
                break;
            case MENU_RCMON:
                if (strcmp(U2buffer, (const char *) "DISABLE") == 0) {
                    RCmon = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "ENABLE") == 0) {
                    RCmon = 1;
                    write_settings();
                }
                break;
            case MENU_MAINSMETER:
            case MENU_PVMETER:
            case MENU_EVMETER:
                for(i = 0; i <= EM_CUSTOM; i++){                                // Don't accept Sensorbox for EVMETER
                    if ( (strcmp(U2buffer, EMConfig[i].Desc) == 0) && !(i == EM_SENSORBOX && menu == MENU_EVMETER) ) {
                        setItemValue(menu, i);
                        write_settings();
                    }
                }
                break;
            case MENU_MAINSMETERMEASURE:
                if (strcmp(U2buffer, (const char *) "ALL") == 0) {
                    MainsMeterMeasure = 0;
                    write_settings();
                } else if (strcmp(U2buffer, (const char *) "HOME") == 0) {
                    MainsMeterMeasure = 1;
                    write_settings();
                }
                break;
            case MENU_RFIDREADER:
                for(i = 0; i < 6; i++) {
                    if (strcmp(U2buffer, StrRFIDReader[i]) == 0) {
                        RFIDReader = i;
                        write_settings();
                    }
                }
                break;
            default:
                n = (unsigned int) atoi(U2buffer);
                OK = setItemValue(menu, n);
                write_settings();
                if(!OK) printf("\nError! please check limits\n");
                break;
        }

        menu = 0;
        MenuItemsCount = getMenuItems();
    }

    // Show active item configuration
    if (menu > MENU_ENTER && menu < MENU_EXIT) printf("%s is set to: %s\n", MenuStr[menu].Desc, getMenuItemOption(menu));
    if (menu == MENU_MAINS || menu == MENU_MAX || menu == MENU_CIRCUIT) {
        printf("WARNING - DO NOT SET CURRENT HIGHER THAN YOUR CIRCUIT BREAKER\n");
        printf("OR GREATER THAN THE RATED VALUE OF THE EVSE\n");
    }

    switch (menu) {
        case 0:
            printf("\n----------------------------- SMART EVSE -----------------------------\n v");
            printf(VERSION);
            printf(" for instructions, see www.smartevse.org\n");
            printf(" Internal Temperature: %i C  SN: %06u\n", TempEVSE, serialnr);
            printf("----------------------------------------------------------------------\n");
            for(i = 0; i < MenuItemsCount - 1; i++) {
                printf("%-07s - %-51s - ", MenuStr[MenuItems[i]].Key, MenuStr[MenuItems[i]].Desc);
                if (MenuItems[i] == MENU_CAL) {
                    for (x = 0 ; x < 3 ; x++)
                        printf("CT%u:%d.%u A ", x+1, Irms[x]/10, (unsigned int)abs(Irms[x])%10 );
                } else {
                    printf(getMenuItemOption(MenuItems[i]));
                }
                printf("\n");
            }

            printf(">");
            break;
        case MENU_CONFIG:
            printf("Enter new Configuration (FIXED/SOCKET): ");
            break;
        case MENU_MODE:
            printf("Enter new EVSE Mode (NORMAL/SMART/SOLAR): ");
            break;
        case MENU_START:
            printf("Enter new Surplus start Current (%u-%u): -", MenuStr[menu].Min, MenuStr[menu].Max);
            break;
        case MENU_LOADBL:
            printf("Enter Load Balancing mode (%s", StrLoadBl[0]);
            for(i = 1; i <= NR_EVSES; i++) {
                printf("/%s", StrLoadBl[i]);
            }
            printf("): ");
            break;
        case MENU_LOCK:
            printf("Enter new Cable lock mode (DISABLE/SOLENOID/MOTOR): ");
            break;
        case MENU_SWITCH:
            printf("Access Control on SW (%s", StrSwitch[0]);
            for(i = 1; i < 5; i++) {
                printf("/%s", StrSwitch[i]);
            }
            printf("): ");
            break;
        case MENU_RCMON:
            printf("Residual Current Monitor (DISABLE/ENABLE): ");
            break;
        case MENU_GRID:
            printf("Grid set to (4Wire/3Wire): ");
            break;
        case MENU_CAL:
            printf("CT1 reads: %d.%u A\nEnter new Measured Current for CT1: ", Irms[0]/10, (unsigned int)abs(Irms[0])%10);
            break;
        case MENU_MAINSMETER:
        case MENU_PVMETER:
        case MENU_EVMETER:
            printf("Enter new type (%s", EMConfig[0].Desc);
            for(i = 1; i <= EM_CUSTOM; i++) {                                   // Don't show Sensorbox on EVMETER
                if (!(i == EM_SENSORBOX && menu == MENU_EVMETER)) printf("/%s", EMConfig[i].Desc);
            }
            printf("): ");
            break;
        case MENU_MAINSMETERMEASURE:
            printf("Enter what mains electric meter measure (ALL/HOME): ");
            break;
        case MENU_EMCUSTOM_ENDIANESS:
            printf("Enter new Byte order (0: LBF & LWF, 1: LBF & HWF, 2: HBF & LWF, 3: HBF & HWF): ");
            break;
        case MENU_EMCUSTOM_DATATYPE:
            printf("Enter new Datatype (0: INT32, 1: FLOAT32, 2: INT16): ");
            break;
        case MENU_EMCUSTOM_UDIVISOR:
        case MENU_EMCUSTOM_IDIVISOR:
        case MENU_EMCUSTOM_PDIVISOR:
        case MENU_EMCUSTOM_EDIVISOR:
            printf("Enter new exponent of divisor (0-7): ");
            break;
        case MENU_RFIDREADER:
            printf("Enter new RFID reader mode (%s", StrRFIDReader[0]);
            for(i = 1; i < 6; i++) {
                printf("/%s", StrRFIDReader[i]);
            }
            printf("): ");
            break;
        case MENU_STATE:
            for (n = 0; n < NR_EVSES; n++) {
                printf("EVSE%u:%s(%u.%1uA)", n, getStateName(BalancedState[n]), Balanced[n]/10, Balanced[n]%10);
                if (n < NR_EVSES-1) printf(",");
                else printf("\n");
            }
            menu = 0;
            break;
        default:
            printf("Enter new value (%u-%u): ", MenuStr[menu].Min, MenuStr[menu].Max);
            break;
    }
    ISR2FLAG = 0;                                                               // clear flag
    idx2 = 0;                                                                   // reset buffer pointer
}

// TestIO will be called after a special RS485 command has been received.
void TestIO(void)                                                               // Test connector should be connected to CON1
{
    unsigned char error = 0;

    if (TestState == 255) {
        CCP2CON = 0;                                                            // Disable PWM on LED output
        LATBbits.LATB3 = 0;                                                     // set IO1 to low, State B

        SOLENOID_OFF;
        delay(3000);                                                            // wait 3 seconds for capacitor to charge

        CCP1CON = 0;                                                            // PWM off
        PORTCbits.RC2 = 0;                                                      // Control pilot static -12V
        delay(100);                                                             // wait 100 msec
        if (ReadPilot() == PILOT_DIODE) TestState = STATE_B;                    // should be -12V
        else error = 1;
    } else if (TestState == STATE_B && State == STATE_B)                        // +9V (B state) OK, now test PP input
    {
        ProximityPin();
        if (MaxCapacity != 32) error ^= 2;                                      // error!
        TestState = STATE_C;
        LATBbits.LATB3 = 1;                                                     // set IO1 to high State B->State C
    } else if (TestState == STATE_C && State == STATE_C)                        //+6V (C state) OK
    {
        Lock = 1;                                                               // enable Lock
        TRISB = 0b10000101;                                                     // RB7(RX2), RB0,2 inputs. all other output
        LATBbits.LATB1 = 1;                                                     // set IO3 to high
        delay(5000);                                                            // wait 5 seconds for capacitor to charge
        if (PORTCbits.RC1 == 1) error ^= 4;                                     // error, Solenoid not activated !

        delay(10);
                                                                                // Contactor + I/O test
        if (PORTBbits.RB2 == 1)                                                 // sample input PIN IO2
        {
            LATBbits.LATB1 = 0;
            delay(10);
            if (PORTBbits.RB2 != 0) error ^= 8;                                 // error
        } else error ^= 8;                                                      // error

        TestState = STATE_CB;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B
    } else if (TestState == STATE_CB && State == STATE_B) {
        TRISB = 0b10000001;                                                     // RB7(RX2), RB0 inputs. all other output
        delay(1000);
        if (PORTCbits.RC1 == 0) error ^= 4;                                     // Solenoid FAIL!!
        else if (!error) {
            TestState = 80;
            Lock = 0;
            GLCD();
        }
    }

    if (error) {
        TRISB = 0b10000001;                                                     // Reset all IO to default values
        LATBbits.LATB1 = 0;
        LATBbits.LATB2 = 0;
        LATBbits.LATB3 = 0;                                                     // set IO1 to low State C->State B
        Lock = 0;
        Error |= Test_IO;
        TestState = error;
        setState(STATE_A);
    }
}

void init(void) {
    OSCCON = 0b01101100;                                                        // setup external oscillator
    OSCCON2 = 0b00000100;                                                       // primary Oscillator On.

    RCON = 0b11011111;                                                          // Set Interrupt priority, enable BOR

    PMD0 = 0b00000000;                                                          // Peripheral Module Enable/Disable
    PMD1 = 0b00000000;                                                          // All enabled
    PMD2 = 0b00000000;

    PORTA = 0;                                                                  // Init PORTA
    ANSELA = 0b00000111;                                                        // RA0, RA1, RA2 are analog inputs (pin 2,3,4)
    TRISA = 0b00000111;                                                         // Set RA0,RA1,RA2 as inputs

    PORTB = 0;
    ANSELB = 0;                                                                 // All digital IO
    TRISB = 0b10000111;                                                         // RB7(RX2), RB0-RB2 inputs. all other output
    WPUB = 0b10000111;                                                          // weak pullup on RB7 and RB0-RB2
    INTCON2bits.RBPU = 0;                                                       // Enable weak pullups on PORTB

    PORTC = 0b00000100;                                                         // Set Pilot to +12V at startup
    ANSELC = 0;                                                                 // All digital IO
    TRISC = 0b10000010;                                                         // RC1 and RC7 input (RX1), all other output

    SPBRGH1 = 0x01;                                                             // Initialize UART 1 (RS485)
    SPBRG1 = 0xA0;                                                              // Baudrate 9600

    BAUDCON1 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA1 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA1 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit.

    SPBRGH2 = 0;                                                                // Initialize UART 2
    SPBRG2 = 34;                                                                // Baudrate 115k2 (114285)
    BAUDCON2 = 0b00001000;                                                      // 16 bit Baudrate register is used
    TXSTA2 = 0b00100100;                                                        // Enable TX, 8 bit, Asynchronous mode
    RCSTA2 = 0b10010000;                                                        // Enable serial port TX and RX, 8 bit.

    VREFCON0 = 0b10100000;                                                      // Fixed Voltage reference set to 2.048V

    ADCON0 = 0b00000001;                                                        // ADC On, input AN0 (Pilot)
    ADCON1 = 0;
    ADCON2 = 0b10100101;                                                        // Right justify, Tacq = 8 uS, FOSC/16

    T0CON = 0b10000111;                                                         // Timer 0 @ 16Mhz => 32 uS Timer0, 16 bit counter, 1:256 prescaler

    PR2 = 249;                                                                  // Timer 2 frequency value -> 1Khz @ 16 Mhz
    T2CON = 0b00000110;                                                         // Timer 2 ON, prescaler 1:16
    CCP1CON = 0;                                                                // PWM off (Control Pilot signal)
    CCP2CON = 0;                                                                // PWM off (Led on I/O 1)

    PR4 = 249;                                                                  // Timer 4 frequency value -> 1Khz @ 16 Mhz
    T4CON = 0b00000110;                                                         // Timer 4 ON, prescaler 1:16

    // SPI registers
    SSP1STAT = 0b00000000;                                                      // 0 = Input data sampled at middle of data output time
                                                                                // 0 = Transmit occurs on transition from Idle to active clock state
    SSP1CON1 = 0b00010000;                                                      // Idle state for clock is a high level, SPI Master mode, clock = FOSC/4
    SSP1CON1 = 0b00110000;                                                      // SPI enabled,Idle state for clock is a high level, SPI Master mode, clock = FOSC/4

    PIE1bits.RC1IE = 1;                                                         // enable receive Interrupt for UART1
    PIE3bits.RC2IE = 1;                                                         // enable receive Interrupt for UART2
    PIE5bits.TMR4IE = 1;                                                        // enable Timer4 Interrupt

    INTCONbits.GIEH = 1;                                                        // global High Priority interrupts enabled
    INTCONbits.GIEL = 0;                                                        // global Low Priority interrupts disabled

    SOLENOID_OFF;                                                               // R and W outputs held at Capacitor voltage (+12V)

    CCPR2L = 0;                                                                 // LED DutyCycle 0%
    CCP2CON = 0x0C;                                                             // LED PWM on

    unlockMagic = 0x22;
    printf("\nSmart EVSE powerup.\n");

}


/**
 * Update current data after received current measurement
 */
void UpdateCurrentData(void) {
    unsigned char x;

    // reset Imeasured value (grid power used)
    Imeasured = 0;
    for (x = 0; x < 3; x++) {
        // Imeasured holds highest Irms of all channels
        if (Irms[x] > Imeasured) Imeasured = Irms[x];
    }


    // Load Balancing mode: Smart/Master or Disabled
    if (Mode && LoadBl < 2) {
        // Calculate dynamic charge current for connected EVSE's
        CalcBalancedCurrent(0);

        // No current left, or Overload (2x Maxmains)?
        if (NoCurrent > 2 || (Imeasured > (MaxMains * 20))) {
            // STOP charging for all EVSE's
            // Display error message
            Error |= LESS_6A; //NOCURRENT;
            // Set all EVSE's to State A
            ResetBalancedStates();

            // Broadcast Error code over RS485
            ModbusWriteSingleRequest(BROADCAST_ADR, 0x0001, LESS_6A);
            NoCurrent = 0;
        } else if (LoadBl) BroadcastCurrent();                                  // Master sends current to all connected EVSE's

        if ((State == STATE_B) || (State == STATE_C)) {
            // Set current for Master EVSE in Smart Mode
            SetCurrent(Balanced[0]);
        }
#ifdef LOG_DEBUG_EVSE
        printf("\nSTATE: %s Error: %u StartCurrent: -%i ChargeDelay: %u SolarStopTimer: %u NoCurrent: %u Imeasured: %.1f A IsetBalanced: %.1f A", getStateName(State), Error, StartCurrent,
                                                                        ChargeDelay, SolarStopTimer,  NoCurrent,
                                                                        (double)Imeasured/10,
                                                                        (double)IsetBalanced/10);

        printf("\nL1: %.1f A L2: %.1f A L3: %.1f A Isum: %.1f A", (double)Irms[0]/10, (double)Irms[1]/10, (double)Irms[2]/10, (double)Isum/10);
#endif
    } else Imeasured = 0; // In case Sensorbox is connected in Normal mode. Clear measurement.
}


void receiveEVCurrentMeasurement(unsigned char *buf, unsigned char NodeNr) {
    unsigned char x;
    signed long EV[3]={0, 0, 0};

    x = receiveCurrentMeasurement(buf, Node[NodeNr].EVMeter, EV);
    Node[NodeNr].MinCurrent = 0;
    Node[NodeNr].Phases = 0;
    for (x = 0; x < 3; x++) {
        Node[NodeNr].MinCurrent += (unsigned char)(EV[x] / 100);
        if (EV[x] > 100) Node[NodeNr].Phases++;
    }
#ifdef LOG_INFO_EVSE
    printf("\nNode %u minimum current sum is %u * 0.1 A with %u phases (measured)", NodeNr, Node[NodeNr].MinCurrent, Node[NodeNr].Phases);
#endif
    if (Node[NodeNr].MinCurrent <= 1) {
        Node[NodeNr].MinCurrent = MinCurrent * 10;
#ifdef LOG_WARN_EVSE
        printf("\nMinimum current to low!");
#endif
    }
    EVMeasureNode = 255;
}


void main(void) {
    unsigned char x, leftbutton, RB2low = 0;
    unsigned char pilot, count = 0, timeout = 5;
    unsigned char ActivationTimer = 0, AccessTimer = 0;
    unsigned char Broadcast = 0, RB2count = 0, RB2last = 1;
    signed long CM[3]={0, 0, 0};
    signed long PV[3]={0, 0, 0};
    unsigned char PollEVNode = NR_EVSES;
    signed long EnergyEV = 0;
    unsigned long RB2Timer = 0;                                                 // 1500ms
    unsigned char ResetKwh = 2;                                                 // if set, reset EV kwh meter at state transition B->C
                                                                                // cleared when charging, reset to 1 when disconnected (state A)
    unsigned char CMMeasurePhases;
    unsigned char PortalStarted = 0, WIFItimer = 0;

    init();                                                                     // initialize ports, ADC, UARTs etc

    read_settings();                                                            // from EEprom
    IsetBalanced = MaxMains * 10;                                               // Initially set to MaxMains
    ReadRFIDlist();                                                             // Read all stored RFID's from eeprom

    BACKLIGHT_ON;                                                               // so we can see the version nr at powerup
    GLCD_init();
    GLCD_version();                                                             // Display Version

    RCONbits.POR = 1;                                                           // flag that future resets are not POR resets

    serialnr = getSerialNr();

#ifdef MOD_BOOTLOADER
    x = checkbootloader();                                                      // update the bootloader to v1.06?
    if (x == 2) Error = BL_FLASH;                                               // bootloader update flash write error!
#endif

    setState(STATE_A);

    while (1)                                                                   // MAIN loop
    {

        if (TestState) TestIO();                                                // TestMode. Test all I/O of Module

        if (ISR2FLAG) RS232cli();                                               // RS232 command line interface

        if (DelayedRS485SendBuf && (ModbusTimer > 6)) {

            LATBbits.LATB5 = 1;                                                 // set RS485 transceiver to transmit
            delay(1);
            PIE1bits.TX1IE = 1;                                                 // enable transmit Interrupt for RS485
            DelayedRS485SendBuf = 0;                                            // reset delayed transmission flag
#ifdef LOG_INFO_MODBUS
            printf ("\nDelayed transmission");
#endif
        }

        if (!ISRTXFLAG && TXSTA1bits.TRMT) LATBbits.LATB5 = 0;                  // set RS485 transceiver to receive if the last character has been sent

        BlinkLed();                                                             // Handle the blinking of the 12V LED

        TRISC = 0b10100011;                                                     // Set RC5 and RC0 to input. Make sure there are pull-ups on these pins.
        NOP();
        NOP();
        x = (PORTC & 0b00100001);                                               // Read Two Button Inputs on RC5(>) and RC0(select)
        ButtonState = (x >> 3);
        ButtonState |= ((x << 1) & 0x02);                                       // arranged to lowest bits
        ButtonState |= (PORTB & 0x01);                                          // Read the state of the last button RB0(<).
        TRISC = 0b10000010;                                                     // RC1 and RC7 input (RX1), all other output

                                                                                // Any button pressed or just released?
        if ((ButtonState != 0x07) || (ButtonState != OldButtonState)) GLCDMenu(ButtonState);

        if (LCDNav > MENU_ENTER && LCDNav < MENU_EXIT && (ScrollTimer + 5000 < Timer) && (!SubMenu)) GLCDHelp(); // Update/Show Helpmenu

        // Left button pressed, switch is set to "Sma-Sol B" and Mode is Smart or Solar?
        if (!LCDNav && ButtonState == 0x6 && Mode && !leftbutton && Switch == SMART_SOLAR_BUTTON) {
            setMode(~Mode & 0x3);                                               // Change from Solar to Smart mode and vice versa.
            leftbutton = 5;
        } else if (leftbutton && ButtonState == 0x7) leftbutton--;


        // External switch changed state?
        if (PORTBbits.RB2 != RB2last || RB2low) {
            // make sure that noise on the input does not switch
            if (RB2count++ > 50 || RB2low) {
                RB2last = PORTBbits.RB2;

                if (RB2last == 0) {
                    // Switch input pulled low
                    switch (Switch) {
                        case ACCESS_BUTTON:
                            setAccess(!Access_bit);                             // Toggle Access bit on/off
#ifdef LOG_DEBUG_EVSE
                            printf("\nAccess: %d ", Access_bit);
#endif
                            break;
                        case ACCESS_SWITCH:
                            setAccess(true);
                            break;
                        case SMART_SOLAR_BUTTON: // Smart-Solar Button or hold button for 1,5 second to STOP charging
                            if (RB2low == 0) {
                                RB2low = 1;
                                RB2Timer = Timer;
                            }
                            if (RB2low && Timer > RB2Timer + 1500) {
                                if (State == STATE_C) {
                                    setState(STATE_C1);
                                    if (!TestState) ChargeDelay = 15;           // Keep in State B for 15 seconds, so the Charge cable can be removed.
                                RB2low = 2;
                                }
                            }
                            break;
                        case SMART_SOLAR_SWITCH:
                            if (Mode == MODE_SOLAR) {
                                setMode(MODE_SMART);
                            }
                            break;
                        default:
                            if (State == STATE_C) {                             // Menu option Access is set to Disabled
                                setState(STATE_C1);
                                if (!TestState) ChargeDelay = 15;               // Keep in State B for 15 seconds, so the Charge cable can be removed.
                            }
                            break;
                    }

                    // Reset RCD error when button is pressed
                    // RCD was tripped, but RCD level is back to normal
                    if (RCmon == 1 && (Error & RCD_TRIPPED) && PORTBbits.RB1 == 0) {
                        // Clear RCD error
                        Error &= ~RCD_TRIPPED;
                    }
                    // Also light up the LCD backlight
                    BacklightTimer = BACKLIGHT;                                 // Backlight ON
                    BACKLIGHT_ON;

                } else {
                    // Switch input released
                    switch (Switch) {
                        case ACCESS_SWITCH:
                            setAccess(false);
                            break;
                        case SMART_SOLAR_BUTTON:
                            if (RB2low != 2) {
                                if (Mode == MODE_SMART) {
                                    setMode(MODE_SOLAR);
                                } else if (Mode == MODE_SOLAR) {
                                    setMode(MODE_SMART);
                                }
                            }
                            RB2low = 0;
                            break;
                        case SMART_SOLAR_SWITCH:
                            if (Mode == MODE_SMART) setMode(MODE_SOLAR);
                            break;
                        default:
                            break;
                    }
                }

                RB2count = 0;
            }
        } else RB2count = 0;


        if (RCmon == 1 && PORTBbits.RB1 == 1)                                   // RCD monitor active, and RCD DC current > 6mA ?
        {
           if (PORTBbits.RB1 == 1) {                                            // check again, to prevent voltage spikes from tripping the RCD detection (2.07)
                if (State) setState(STATE_B1);
                Error = RCD_TRIPPED;
                LCDTimer = 0;                                                   // display the correct error message on the LCD
            }
        }

        // One RFID card can Lock/Unlock the charging socket (like a public charging station)
        if (RFIDReader == 2) {
           if (Access_bit == 0) UnlockCable = 1;
           else UnlockCable = 0;
        // The charging socket is unlocked when charging stops.
        } else {
            if (State != STATE_C) UnlockCable = 1;
            else UnlockCable = 0;
        }
        // If the cable is connected to the EV, the cable will be locked.
        if (State == STATE_B || State == STATE_C) LockCable = 1;
        else LockCable = 0;


        // ############### EVSE State A #################

        if (State == STATE_A || State == STATE_COMM_B || State == STATE_B1)
        {
            pilot = ReadPilot();

            if (pilot == PILOT_12V) {                                           // Check if we are disconnected, or forced to State A, but still connected to the EV

                // If the RFID reader is set to EnableOne mode, and the Charging cable is disconnected
                // We start a timer to re-lock the EVSE (and unlock the cable) after 60 seconds.
                if (RFIDReader == 2 && AccessTimer == 0 && Access_bit == 1) AccessTimer = RFIDLOCKTIME;

                if (State != STATE_A) setState(STATE_A);                        // reset state, incase we were stuck in STATE_COMM_B
                NextState = NOSTATE;
                if (!ResetKwh) ResetKwh = 1;                                    // when set, reset EV kWh meter on state B->C change.
            } else if ( (pilot == PILOT_9V || pilot == STATE_A_TO_C)
                && Error == NO_ERROR && ChargeDelay == 0 && Access_bit
                && State != STATE_COMM_B) {                                     // switch to State B ?
                                                                                // Allow to switch to state C directly if STATE_A_TO_C is set to PILOT_6V (see EVSE.h)
                if (NextState == STATE_B)                                       // Access is permitted when Access_bit set
                {
                    if (count++ > 25)                                           // repeat 25 times (changed in v2.05)
                    {
                        DiodeCheck = 0;
                        ProximityPin();                                         // Sample Proximity Pin
#ifdef LOG_DEBUG_EVSE
                        printf("\nCable limit: %uA  Max: %uA", MaxCapacity, MaxCurrent);
#endif
                        if (MaxCurrent > MaxCapacity) ChargeCurrent = MaxCapacity * 10; // Do not modify Max Cable Capacity or MaxCurrent (fix 2.05)
                        else ChargeCurrent = MaxCurrent * 10;                   // Instead use new variable ChargeCurrent

                        if (LoadBl > 1)                                         // Load Balancing : Node
                        {                                                       // Send command to Master, followed by Max Charge Current
                            setState(STATE_COMM_B);                             // Node wants to switch to State B
                        } else if (IsCurrentAvailable(0)) {                     // Load Balancing: Master or Disabled
                            BalancedMax[0] = MaxCapacity * 10;
                            Balanced[0] = ChargeCurrent;                        // Set pilot duty cycle to ChargeCurrent (v2.15)
                            setState(STATE_B);                                  // switch to State B
                            ActivationMode = 30;                                // Activation mode is triggered if state C is not entered in 30 seconds.
                            AccessTimer = 0;
                        } else if (Mode == MODE_SOLAR) {                        // Not enough power:
                            Error |= NO_SUN;                                    // Not enough solar power
                        } else Error |= LESS_6A;                                // Not enough power available
                   }
                } else {
                    NextState = STATE_B;
                    count = 0;
                }
            } else NextState = NOSTATE;
        }

        if (State == STATE_COMM_B_OK) {
            setState(STATE_B);
            ActivationMode = 30;                                                // Activation mode is triggered if state C is not entered in 30 seconds.
            AccessTimer = 0;
        }

        // ############### EVSE State B #################

        if (State == STATE_B || State == STATE_COMM_C)
        {                                                                       // measure voltage at ~5% and ~90% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // PWM cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if (pilot == PILOT_12V)                                         // Disconnected?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            setState(STATE_A);                                  // switch to STATE_A
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_6V) {
                    if ((NextState == STATE_C) && (DiodeCheck == 1)) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            if ((Error == NO_ERROR) && (ChargeDelay == 0)) {
                                if (EVMeter && ResetKwh) {
                                    EnergyMeterStart = EnergyEV;                // store kwh measurement at start of charging.
                                    ResetKwh = 0;                               // clear flag, will be set when disconnected from EVSE (State A)
                                }
                                if (LoadBl > 1)                                 // Load Balancing : Node
                                {                                               // Send command to Master, followed by Charge Current
                                    if (State != STATE_COMM_C) setState(STATE_COMM_C);
                                } else {                                        // Load Balancing: Master or Disabled
                                    BalancedMax[0] = ChargeCurrent;
                                    if (IsCurrentAvailable(0)) {
                                        Balanced[0] = 0;                        // For correct baseload calculation set current to zero
                                        CalcBalancedCurrent(1);                 // Calculate charge current for all connected EVSE's

                                        setState(STATE_C);                      // switch to STATE_C
                                        if (!LCDNav) GLCD();                    // Don't update the LCD if we are navigating the menu
                                                                                // immediately update LCD (20ms)
                                    }
                                    else if (Mode == MODE_SOLAR) {              // Not enough power:
                                        Error |= NO_SUN;                        // Not enough solar power
                                    } else Error |= LESS_6A;                    // Not enough power available
                                }
                            }
                        }
                    } else {
                        NextState = STATE_C;
                        count = 0;
                    }
                } else {                                                        // PILOT_9V

                    if (ActivationMode == 0) {
                        setState(STATE_ACTSTART);
                        ActivationTimer = 3;
                        CCP1CON = 0;                                            // PWM off
                        PORTCbits.RC2 = 0;                                      // Control pilot static -12V
                    }
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
            if (TMR2 > 230)                                                     // PWM > 92%
            {
                while (TMR2 < 242);                                             // wait till TMR2 is in range, otherwise we'll miss it (blocking)
                if ((TMR2 > 241) && (TMR2 < 249))                               // PWM cycle >= 96% (should be low)
                {
                    pilot = ReadPilot();
                    if (pilot == PILOT_DIODE) DiodeCheck = 1;                   // Diode found, OK
                    else DiodeCheck = 0;
                }
            }
        }

        // ############### EVSE State C1 #################

        if (State == STATE_C1)
        {
            pilot = ReadPilot();
            if (pilot == PILOT_12V)
            {                                                                   // Disconnected or connected to EV without PWM
                if (NextState == STATE_A)
                {
                    if (count++ > 25)
                    {                                                           // repeat 25 times
                        setState(STATE_A);                                      // switch to STATE_A
                    }
                } else {
                    NextState = STATE_A;
                    count = 0;
                }
            }
            else if (pilot == PILOT_9V)
            {
                if (NextState == STATE_B1)
                {
                    if (count++ > 25)
                    {                                                           // repeat 25 times
                        setState(STATE_B1);                                     // switch to State B1
                    }
                } else {
                    NextState = STATE_B1;
                    count = 0;
                }
            }
        }

        if (State == STATE_ACTSTART && ActivationTimer == 0) {
            setState(STATE_B);                                                  // Switch back to State B
            PORTCbits.RC2 = 1;                                                  // Control pilot static +12V
            ActivationMode = 255;                                               // Disable ActivationMode
        }

        if (State == STATE_COMM_C_OK) {
            setState(STATE_C);                                                  // switch to STATE_C
            NextState = NOSTATE;                                                // no State to switch to
            if (!LCDNav) GLCD();                                                // immediately update LCD
        }

        // ############### EVSE State C #################

        if (State == STATE_C)
        {                                                                       // measure voltage at ~5% of PWM cycle
            if ((TMR2 > 7) && (TMR2 < 24))                                      // cycle 3% - 9% (should be high)
            {
                pilot = ReadPilot();
                if ((pilot == PILOT_12V) || (pilot == PILOT_NOK))               // Disconnected or Error?
                {
                    if (NextState == STATE_A) {
                        if (count++ > 25)                                       // repeat 25 times (changed in v2.05)
                        {
                            setState(STATE_A);                                  // switch back to STATE_A
                            GLCD_init();                                        // Re-init LCD
                        }
                    } else {
                        NextState = STATE_A;
                        count = 0;
                    }
                } else if (pilot == PILOT_9V) {
                    if (NextState == STATE_B) {
                        if (count++ > 25)                                       // repeat 25 times
                        {
                            CONTACTOR_OFF;                                      // Contactor OFF
                            setState(STATE_B);                                  // switch back to STATE_B
                            GLCD_init();                                        // Re-init LCD (200ms delay)
                            DiodeCheck = 0;
                        }
                    } else {
                        NextState = STATE_B;
                        count = 0;
                    }
                } else {                                                        // PILOT_6V
                    NextState = NOSTATE;                                        // no State to switch to
                }
            }
        } // end of State C code


        if (RCSTA1bits.OERR)                                                    // Uart1 Overrun Error?
        {
            RCSTA1bits.CREN = 0;
            RCSTA1bits.CREN = 1;                                                // Restart Uart
        }
        if (RCSTA2bits.OERR)                                                    // Uart2 Overrun Error?
        {
            RCSTA2bits.CREN = 0;
            RCSTA2bits.CREN = 1;                                                // Restart Uart
        }

        // The following code will be executed every second, except when there is a state change C->B happening
        x = TMR0L;
        if (TMR0H >= 0x3d &&  (NextState == NOSTATE || State != STATE_C) )      // 1 second timer
        {
            TMR0H = 0;
            TMR0L = 0;

            Temp();                                                             // once a second, measure temperature

//            printf("locktimer: %lu timer: %lu\n lockstatus: %u", locktimer, Timer, lockstatus);

            CheckRFID();

            if (State == STATE_B && ActivationMode < 255) ActivationMode--;     // decrease 30 sec counter when in State B
            if (State == STATE_ACTSTART && ActivationTimer) ActivationTimer--;
            if (State == STATE_C1) {
                if (C1Timer) C1Timer--;                                         // if the EV does not stop charging in 6 seconds, we will open the contactor.
                else {
                    printf("\nState C1 timeout!");
                    CONTACTOR_OFF;                                              // Contactor OFF
                    setState(STATE_B1);                                         // switch back to STATE_B1
                    GLCD_init();                                                // Re-init LCD (200ms delay)
                    DiodeCheck = 0;
                    ChargeTimer = 15;
                }
            }

            // When Solar Charging, once the current drops to MINcurrent a timer is started.
            // Charging is stopped when the timer reaches the time set in 'StopTime' (in minutes)
            // Except when Stoptime =0, then charging will continue.

            if (SolarStopTimer) {
                SolarStopTimer--;
                if (SolarStopTimer == 0) {

                    if (State == STATE_C) setState(STATE_C1);                   // tell EV to stop charging
                    Error |= NO_SUN;                                            // Set error: NO_SUN

                    ResetBalancedStates();                                      // reset all states
                }
            }

            if (ChargeDelay) ChargeDelay--;                                     // Decrease Charge Delay counter

            if (AccessTimer && State == STATE_A) {
                if (--AccessTimer == 0) {
                    setAccess(false);                                           // re-lock EVSE
                }
            } else AccessTimer = 0;                                             // Not in state A, then disable timer

            //Local Wifimode and Sensorbox mode are not the same.
            if (WIFImode !=  WIFImodeSB && WIFItimer == 0 && SB2SoftwareVer) {
                if (WIFImode == 2 && LCDTimer >= 10 && WiFiAPSTA != 1 && !PortalStarted) {
                    printf("\nStart Portal...");
                    PortalStarted = 1;
                    ModbusWriteSingleRequest(0x0A, 0x801, WIFImode);
                } else if (WIFImode == 1) {
                    printf("\nStart Wifi");
                    ModbusWriteSingleRequest(0x0A, 0x801, WIFImode);
                } else if (WIFImode == 0) {
                    printf("\nStop Wifi");
                    ModbusWriteSingleRequest(0x0A, 0x801, WIFImode);
                } else if (WIFImodeSB == 1 && PortalStarted) {
                    printf("\nExit Portal. Start WiFi");
                    WIFImode = 1;
                    LCDNav = 0;
                    PortalStarted = 0;
                    write_settings();
                }
                WIFItimer = 5;
            }
            if (WIFItimer) WIFItimer--;

            if ((TempEVSE < 55) && (Error & TEMP_HIGH)) // Temperature below limit?
            {
                Error &= ~TEMP_HIGH; // clear Error
            }

            if ( (Error & (LESS_6A|NO_SUN) ) && (LoadBl < 2) && (IsCurrentAvailable(0))) {
                Error &= ~LESS_6A;                                              // Clear Errors if there is enough current available, and Load Balancing is disabled or we are Master
                Error &= ~NO_SUN;
#ifdef LOG_DEBUG_EVSE
                printf("\nNo sun/current Errors Cleared.");
#endif
                ModbusWriteSingleRequest(BROADCAST_ADR, 0x0001, Error);         // Broadcast
            }

            if (ExternalMaster) {
                ExternalMaster--;
            }

            // Charge timer
            for (x = 0; x < NR_EVSES; x++) {
                if (BalancedState[x] == STATE_C) Node[x].Timer++;
            }
            if (CMMeasureTimer) {
                CMMeasureTimer--;
                switch (CMMeasureTimer % 12) {
                    case 4:
                        // Store 8 A measurements (and continue charging with 6 A)
                        memcpy (Imem, Irms, 3 * sizeof(int));
#ifdef LOG_DEBUG_EVSE
                        printf("\nRemember Irms");
#endif
                        CMMeasured = true;
                        break;
                    case 0:
                        // Count used phases
                        CMMeasurePhases = 0;
                        for (x = 0; x < 3; x++) {
                            // Phase change between -3 A and -1 A
                            if (Imem[x] - 30 < Irms[x] && Irms[x] < Imem[x] - 10) CMMeasurePhases++;
                        }
#ifdef LOG_DEBUG_EVSE
                        printf("\nCount %u phases on change from 8 A to 6 A", CMMeasurePhases);
#endif
                        CMMeasured = false;

                        // Is previous phase count available
                        if (Node[CMMeasureNode].Phases) {
                            // Compare phase count
                            if (Node[CMMeasureNode].Phases == CMMeasurePhases) {
                                Node[CMMeasureNode].MinCurrent = Node[CMMeasureNode].Phases * MinCurrent * 10;
#ifdef LOG_INFO_EVSE
                                printf("\nNode %u minimum current sum is %u * 0.1 A with %u phases (guessed)", CMMeasureNode, Node[CMMeasureNode].MinCurrent, Node[CMMeasureNode].Phases);
#endif
                                CMMeasureTimer = 0;
                            }
                        } else {
                            // Remember phase count
                            Node[CMMeasureNode].Phases = CMMeasurePhases;
                        }

                        // Default to MinCurrent on unsuccessful phase count
                        if (CMMeasureTimer == 0 && !Node[CMMeasureNode].MinCurrent) {
                            Node[CMMeasureNode].MinCurrent = MinCurrent * 10;
#ifdef LOG_WARN_EVSE
                            printf("\nUnsuccessful phase count!");
#endif
                        }
                        break;
                }
            }

            if ((timeout == 0) && !(Error & CT_NOCOMM)) {                       // timeout if CT current measurement takes > 10 secs
                Error |= CT_NOCOMM;
                SB2SoftwareVer = 0;                                             // Reset Sensorbox software version
                if (State == STATE_C) setState(STATE_C1);                       // tell EV to stop charging
                else setState(STATE_B1);                                        // when we are not charging switch to State B1
#ifdef LOG_WARN_EVSE
                printf("\nError, communication error!");
#endif
                // Try to broadcast communication error to Nodes if we are Master
                if (LoadBl < 2) ModbusWriteSingleRequest(BROADCAST_ADR, 0x0001, Error);         
                ResetBalancedStates();
            } else if (timeout) timeout--;

            if (TempEVSE >= 65 && !(Error & TEMP_HIGH)) {                       // Temperature too High?
                Error |= TEMP_HIGH;
                if (State == STATE_C) setState(STATE_C1);                       // tell EV to stop charging
                else setState(STATE_B1);                                        // when we are not charging switch to State B1
#ifdef LOG_WARN_EVSE
                printf("\nError, temperature %i C !", TempEVSE);
#endif
                ResetBalancedStates();
            }

            if (Error & (NO_SUN | LESS_6A)) {
#ifdef LOG_INFO_EVSE
                if (Error & NO_SUN) {
                    if (ChargeDelay == 0) printf("\nWaiting for Solar power...");
                } else {
                    if (ChargeDelay == 0) printf("\nNot enough current available!");
                }
#endif
                if (State == STATE_C) setState(STATE_C1);                       // If we are charging, tell EV to stop charging
                else if (State != STATE_C1) setState(STATE_B1);                 // If we are not in State C1, switch to State B1
                ChargeDelay = CHARGEDELAY;                                      // Set Chargedelay
            }

            // once a second, update LCD
            GLCD();

            // Every two seconds request measurement data from sensorbox/kwh meters.
            // and send broadcast to Node controllers.
            if (LoadBl < 2 && !ExternalMaster && !Broadcast--) {                                   // Load Balancing mode: Master or Disabled
                if (Mode) {                                                     // Smart or Solar mode
                    ModbusRequest = 1;                                          // Start with state 1
                } else {                                                        // Normal mode
                    Imeasured = 0;                                              // No measurements, so we set it to zero
                    ModbusRequest = 6;                                          // Start with state 5 (poll Nodes)
                    timeout = 10;                                               // reset timeout counter (not checked for Master)
                }
                Broadcast = 1;                                                  // repeat every two seconds
            }

        } // end 1 second timer


        // Every 2 seconds, request measurements from modbus meters
        if (ModbusRequest && ModbusTimer >= 100 ) {
#ifdef LOG_INFO_MODBUS
            printf("\nModbusRequest %u", ModbusRequest);
#endif
            switch (ModbusRequest++) {                                          // State
                case 1:                                                         // PV kwh meter
                    if (PVMeter) {
                        requestCurrentMeasurement(PVMeter, PVMeterAddress);
                        break;
                    }
                    ModbusRequest++;
                case 2:                                                         // Sensorbox or kWh meter that measures -all- currents
                    requestCurrentMeasurement(MainsMeter, MainsMeterAddress);
                    break;
                case 3:
                    // Find next online SmartEVSE
                    do {
                        PollEVNode++;
                        if (PollEVNode >= NR_EVSES) PollEVNode = 0;
                    } while(Node[PollEVNode].Online == false);

                    // Request Configuration if changed
                    if (Node[PollEVNode].ConfigChanged) {
#ifdef LOG_INFO_MODBUS
                        printf(": Request Configuration Node %u", PollEVNode);
#endif
                        requestNodeConfig(PollEVNode);
                        break;
                    }
                    ModbusRequest++;
                case 4:                                                         // EV kWh meter, Energy measurement (total charged kWh)
                    // Request Energy if EV meter is configured
                    if (Node[PollEVNode].EVMeter) {
#ifdef LOG_INFO_MODBUS
                        printf(": Request Energy Node %u", PollEVNode);
#endif
                        requestEnergyMeasurement(Node[PollEVNode].EVMeter, Node[PollEVNode].EVAddress);
                        break;
                    }
                    ModbusRequest++;
                case 5:                                                         // EV kWh meter, Power measurement (momentary power in Watt)
                    // Request currents for automatic StartCurrent detection
                    if (EVMeasureNode <= NR_EVSES) {
                        requestCurrentMeasurement(Node[EVMeasureNode].EVMeter, Node[EVMeasureNode].EVAddress);
                        break;
                    // Request Power if EV meter is configured
                    } else if (Node[PollEVNode].EVMeter) {
                        requestPowerMeasurement(Node[PollEVNode].EVMeter, Node[PollEVNode].EVAddress);
                        break;
                    }
                    ModbusRequest++;
                case 6:                                                         // Node 1
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    if (LoadBl == 1) {
                        requestNodeStatus(ModbusRequest - 6u);                   // Master, Request Node 1-8 status
                        break;
                    }
                    ModbusRequest = 12;
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                    if (LoadBl == 1) {
                        processAllNodeStates(ModbusRequest - 13u);
                        break;
                    }
                default:
                    if (Mode) {                                                 // Smart/Solar mode
                        if ((Error & CT_NOCOMM) == 0) UpdateCurrentData();      // No communication error with Sensorbox /Kwh meter?
                                                                                // then update the data and send broadcast to all connected EVSE's
                    } else {                                                    // Normal Mode
                        CalcBalancedCurrent(0);                                 // Calculate charge current for connected EVSE's
                        if (LoadBl == 1) BroadcastCurrent();                    // Send to all EVSE's (only in Master mode)
                        if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // set PWM output for Master
                    }
                    ModbusRequest = 0;
                    break;
            }
        }


        /*  RS485 serial data is received by the ISR routine, and processed here..
            Reads serial packet with Raw Current values, measured from 1-3 CT's, over a RS485 serial line
        */

        // Receive data from modbus
        // last reception more then 3ms ago? // complete packet detected?

        if (idx && (ModbusTimer > 3) ) {                                        // if (idx && Timer > (ModbusTimer + 3)) {
            memcpy(U1packet, U1buffer, idx);                                    // store received data packet
            ISRFLAG = idx;                                                      // set flag to length of data packet
            idx = 0;                                                            // ready to receive a new packet

            ModbusDecode(U1packet, ISRFLAG);

            // Data received is a response to an earlier request from the master.
            if (Modbus.Type == MODBUS_RESPONSE) {
                //printf("\nModbus Response Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                switch (Modbus.Function) {
                    case 0x03: // (Read holding register)
                    case 0x04: // (Read input register)
                        if (PVMeter && Modbus.Address == PVMeterAddress && Modbus.Register == EMConfig[PVMeter].IRegister) {
                            // packet from PV electric meter
                            receiveCurrentMeasurement(Modbus.Data, PVMeter, PV);

                        } else if (MainsMeter && Modbus.Address == MainsMeterAddress && Modbus.Register == EMConfig[MainsMeter].IRegister) {
                            // packet from Mains electric meter
                            x = receiveCurrentMeasurement(Modbus.Data, MainsMeter, CM);
                            if (x && LoadBl <2) timeout = 10;                   // only reset timeout when data is ok, and Master/Disabled

                            // Calculate Isum (for nodes and master)
                            Isum = 0;
                            for (x = 0; x < 3; x++) {
                                // Calculate difference of Mains and PV electric meter
                                if (PVMeter) CM[x] -= PV[x];                    // CurrentMeter and PV resolution are 1mA
                                Irms[x] = (signed int)(CM[x] / 100);            // reduce resolution of Irms to 100mA
                                Isum += Irms[x];                                // Isum has a resolution of 100mA
                            }

                        } else if (EVMeasureNode <= NR_EVSES) {
                            // Automatic StartCurrent detection for Node on Master
                            if (Modbus.Address == Node[EVMeasureNode].EVAddress && Modbus.Register == EMConfig[Node[EVMeasureNode].EVMeter].IRegister) {
                                receiveEVCurrentMeasurement(Modbus.Data, EVMeasureNode);
                            }
                        } else if (EVMeter && Modbus.Address == EVMeterAddress) {
                            // Packet from EV electric meter
                            if (Modbus.Register == EMConfig[EVMeter].ERegister) {
                                // Energy measurement
                                EnergyEV = receiveEnergyMeasurement(Modbus.Data, EVMeter);
                                if (ResetKwh == 2) EnergyMeterStart = EnergyEV; // At powerup, set EnergyEV to kwh meter value
                                EnergyCharged = EnergyEV - EnergyMeterStart;    // Calculate Energy
                            } else if (Modbus.Register == EMConfig[EVMeter].PRegister) {
                                // Power measurement
                                PowerMeasured = receivePowerMeasurement(Modbus.Data, EVMeter);
                            } else if (Modbus.Register == EMConfig[EVMeter].IRegister) {
                                // Current measurement
                                receiveEVCurrentMeasurement(Modbus.Data, 0);
                            }
                        } else if (LoadBl == 1 && Modbus.Address > 1 && Modbus.Address <= NR_EVSES) {
                            // Packet from a Node EVSE, only for Master!
                            if (Modbus.Register == 0x0000) {
                                // Node status
                                receiveNodeStatus(Modbus.Data, Modbus.Address - 1u);
                            }  else if (Modbus.Register == 0x0108) {
                                // Node configuration
                                receiveNodeConfig(Modbus.Data, Modbus.Address - 1u);
                            }
                        }
                        break;
                    default:
                        break;
                }
            // Data received is a request from the master to a device on the bus.
            } else if (Modbus.Type == MODBUS_REQUEST) {
                //printf("\nModbus Request Address %i / Function %02x / Register %02x",Modbus.Address,Modbus.Function,Modbus.Register);
                                                                                // No timeout reset here, as it is a request, no response!!!!
                // Special TestIO message?
                if (Modbus.Address == 0x0a && Modbus.Function == 0x06 && Modbus.Register == 0xa8 && Modbus.Value == 0x494f && !TestState) {
                    TestState = 255;
                    break;
                }

                // Master receive modbus request (by Sensorbox or other device)
                if (LoadBl < 2) {
                    ExternalMaster = 4;
#ifdef LOG_WARN_MODBUS
                    printf("\nAnother modbus master detected");
#endif
                }

                // Broadcast or addressed to this device
                if (Modbus.Address == BROADCAST_ADR || (LoadBl == 0 && Modbus.Address == 0x01) || (LoadBl > 0 && Modbus.Address == LoadBl)) {
                    switch (Modbus.Function) {
                        case 0x03: // (Read holding register)
                        case 0x04: // (Read input register)
                            // Addressed to this device
                            if (Modbus.Address != BROADCAST_ADR) {
                                ReadItemValueResponse();
                            }
                            break;
                        case 0x06: // (Write single register)
                            WriteItemValueResponse();
                            break;
                        case 0x10: // (Write multiple register))
                            // 0x0020: Balance currents
                            if (Modbus.Register == 0x0020 && LoadBl > 1) {      // Message for Node(s)
                                Balanced[0] = (Modbus.Data[(LoadBl - 1) * 2] <<8) | Modbus.Data[(LoadBl - 1) * 2 + 1];
                                if (Balanced[0] == 0 && State == STATE_C) setState(STATE_C1);               // tell EV to stop charging if charge current is zero
                                else if ((State == STATE_B) || (State == STATE_C)) SetCurrent(Balanced[0]); // Set charge current, and PWM output
#ifdef LOG_DEBUG_MODBUS
                                printf("\nBroadcast received, Node %u.%1u A", Balanced[0]/10, Balanced[0]%10);
#endif
                                timeout = 10;                                   // reset 10 second timeout
                            } else {
                                WriteMultipleItemValueResponse();
                            }
                            break;
                        default:
                            break;
                    }
                }
            } else if (Modbus.Type == MODBUS_EXCEPTION) {
#ifdef LOG_DEBUG_MODBUS
                printf("\nModbus Address %02x exception %u received", Modbus.Address, Modbus.Exception);
#endif
#ifdef LOG_WARN_MODBUS
            } else {
                printf("\nCRC invalid\n");
#endif
            }
        } // (ISRFLAG > 1) 	 complete packet detected?

        if ((Error & CT_NOCOMM) && timeout == 10) Error &= ~CT_NOCOMM;          // Clear communication error, if present
    } // end of while(1) loop
}
