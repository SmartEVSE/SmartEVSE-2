/*
;	 Project:       Smart EVSE
;
; This code will overwrite v 1.05 of the bootloader with version 1.06
; Version 1.06 has much better protection against unintended flash writes/erases
;
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.
 */

#include <xc.h>
#include <string.h>

#include "bootloader.h"

const unsigned char bootloader[] = {
	0x06, 0xD0, 0x0F, 0x01, 0x3A, 0x9F, 0xD0, 0xB2, 0x81, 0xBE, 0x7E, 0xEF, 0x7E, 0xF0, 0x55, 0x0E, 
	0x04, 0x6E, 0xAA, 0x0E, 0x05, 0x6E, 0x0F, 0x01, 0x3A, 0x9F, 0x20, 0xEE, 0x00, 0xF0, 0x00, 0x01, 
	0x81, 0xAE, 0xFE, 0xD7, 0x90, 0x0E, 0x71, 0x6E, 0x26, 0x0E, 0x72, 0x6E, 0x70, 0x86, 0x02, 0x0E, 
	0xD5, 0x6E, 0x71, 0x98, 0x74, 0x50, 0x74, 0x50, 0xD7, 0x6A, 0xD6, 0x6A, 0xF2, 0x94, 0x4E, 0xD8, 
	0xD5, 0x8E, 0x4C, 0xD8, 0xD5, 0x9E, 0xF2, 0xB4, 0xF7, 0xD7, 0xD6, 0xCF, 0x75, 0xFF, 0xD7, 0xCF, 
	0x76, 0xFF, 0x71, 0x88, 0x2B, 0xD9, 0x0F, 0x0A, 0xEC, 0xE1, 0x0F, 0x0E, 0x22, 0xD9, 0x00, 0xEE, 
	0x05, 0xF0, 0x24, 0xD9, 0x0F, 0x0A, 0xF9, 0xE0, 0x02, 0x50, 0x04, 0x0A, 0x07, 0xE0, 0x02, 0x50, 
	0x05, 0x0A, 0x01, 0xE1, 0x1B, 0xD9, 0x02, 0xC0, 0xEC, 0xFF, 0xF3, 0xD7, 0x10, 0xEE, 0x06, 0xF0, 
	0x00, 0x6A, 0x01, 0x6A, 0xED, 0xCF, 0xF4, 0xFF, 0xE6, 0x50, 0x30, 0xD8, 0xE2, 0x50, 0xEA, 0x62, 
	0xFB, 0xD7, 0xE1, 0x50, 0xE9, 0x62, 0xF8, 0xD7, 0x01, 0x50, 0xF4, 0x62, 0xCA, 0xD7, 0x00, 0x50, 
	0xEF, 0x62, 0xC7, 0xD7, 0x00, 0x6A, 0x01, 0x6A, 0x07, 0x50, 0xF6, 0x6E, 0xA9, 0x6E, 0x08, 0x50, 
	0xF7, 0x6E, 0xAA, 0x6E, 0x09, 0xC0, 0xF8, 0xFF, 0x00, 0xEE, 0x0C, 0xF0, 0x0A, 0x0E, 0x06, 0x60, 
	0xB8, 0xD7, 0xF9, 0x50, 0x06, 0x44, 0xF9, 0x26, 0x27, 0xD0, 0x2F, 0xD0, 0x39, 0xD0, 0x4F, 0xD0, 
	0x7C, 0xD0, 0xA8, 0xD0, 0xB5, 0xD0, 0xC4, 0xD0, 0x98, 0xD7, 0xFF, 0x00, 0x04, 0x00, 0xF2, 0xB4, 
	0x12, 0x00, 0x81, 0xBE, 0xFC, 0xD7, 0x81, 0xAE, 0xFE, 0xD7, 0x12, 0x00, 0x01, 0x18, 0x00, 0xC0, 
	0x01, 0xF0, 0x00, 0x6E, 0xE8, 0x3A, 0x0F, 0x0B, 0x00, 0x1A, 0x00, 0x38, 0xF0, 0x0B, 0x01, 0x1A, 
	
    0x00, 0x38, 0xE8, 0x44, 0x01, 0x1A, 0xE0, 0x0B, 0x01, 0x1A, 0x00, 0x1A, 0x12, 0x00, 0x00, 0x03, 
	0x01, 0x06, 0xFF, 0x84, 0x00, 0xFD, 0x00, 0x00, 0x0E, 0x0E, 0xF6, 0x6E, 0xFE, 0x0E, 0xF7, 0x6E, 
	0x00, 0x0E, 0xF8, 0x6E, 0x0A, 0x0E, 0x0B, 0x6E, 0x0C, 0x6A, 0x09, 0x00, 0xF5, 0x50, 0xAD, 0xD8, 
	0xDD, 0xDF, 0x0B, 0x06, 0x00, 0x0E, 0x0C, 0x5A, 0x0B, 0x50, 0x0C, 0x10, 0xF6, 0xE1, 0x9E, 0xD0, 
	0x09, 0x00, 0xF5, 0x50, 0xD3, 0xDF, 0xF6, 0x50, 0x3F, 0x0B, 0xFA, 0xE1, 0x00, 0x50, 0xC5, 0xEC, 
	0x7F, 0xF0, 0x01, 0x50, 0xC5, 0xEC, 0x7F, 0xF0, 0x0B, 0x06, 0x00, 0x0E, 0x0C, 0x5A, 0x0B, 0x50, 
	0x0C, 0x10, 0xEE, 0xE1, 0x8F, 0xD0, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xC0, 0x0E, 
	0xF6, 0x16, 0x00, 0x0E, 0xF6, 0x5C, 0x00, 0x0E, 0xF7, 0x58, 0x01, 0x0E, 0xF8, 0x58, 0x02, 0xE6, 
	0xA6, 0x6A, 0x17, 0xD0, 0x00, 0x0E, 0xF6, 0x5C, 0xFD, 0x0E, 0xF7, 0x58, 0x00, 0x0E, 0xF8, 0x58, 
	0x0D, 0xE6, 0x00, 0x0E, 0xF6, 0x5C, 0x00, 0x0E, 0xF7, 0x58, 0x01, 0x0E, 0xF8, 0x58, 0x06, 0xE7, 
	0xA6, 0x6A, 0x07, 0xD0, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x94, 0x0E, 0xA6, 0x6E, 
	0x8B, 0xD8, 0x40, 0x0E, 0xF6, 0x5E, 0xE8, 0x6A, 0xF7, 0x5A, 0xF8, 0x5A, 0x0B, 0x2E, 0xD7, 0xD7, 
	0x59, 0xD0, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xC0, 0x0E, 0xF6, 0x16, 0x00, 0x0E, 
	0xF6, 0x5C, 0x00, 0x0E, 0xF7, 0x58, 0x01, 0x0E, 0xF8, 0x58, 0x02, 0xE6, 0xA6, 0x6A, 0x16, 0xD0, 
	0x00, 0x0E, 0xF6, 0x5C, 0xFD, 0x0E, 0xF7, 0x58, 0x00, 0x0E, 0xF8, 0x58, 0x0D, 0xE6, 0x00, 0x0E, 
	0xF6, 0x5C, 0x00, 0x0E, 0xF7, 0x58, 0x01, 0x0E, 0xF8, 0x58, 0x06, 0xE7, 0xA6, 0x6A, 0x06, 0xD0, 
	
    0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x84, 0x0E, 0xA6, 0x6E, 0xEE, 0xCF, 0xF5, 0xFF, 
	0x0D, 0x00, 0xF6, 0x50, 0x3F, 0x0B, 0xFA, 0xE1, 0x0A, 0x00, 0x56, 0xD8, 0x09, 0x00, 0x0B, 0x2E, 
	0xD4, 0xD7, 0x28, 0xD0, 0xA6, 0x6A, 0xA6, 0x80, 0xA8, 0x50, 0xA9, 0x4A, 0xAA, 0x2A, 0x2D, 0xD8, 
	0x5D, 0xDF, 0x0B, 0x06, 0x00, 0x0E, 0x0C, 0x5A, 0x0B, 0x50, 0x0C, 0x10, 0xF4, 0xE1, 0x1E, 0xD0, 
	0x04, 0x0E, 0xA6, 0x6E, 0xEC, 0xCF, 0xA8, 0xFF, 0x3F, 0xD8, 0xA6, 0xB2, 0xFE, 0xD7, 0xA9, 0x4A, 
	0xAA, 0x2A, 0x0B, 0x06, 0x00, 0x0E, 0x0C, 0x5A, 0x0B, 0x50, 0x0C, 0x10, 0xF3, 0xE1, 0x0A, 0xD0, 
	0xC4, 0x0E, 0xA6, 0x6E, 0x08, 0x00, 0xEE, 0x50, 0xF5, 0x62, 0x2C, 0xD8, 0x0B, 0x00, 0x0B, 0x2E, 
	0xFA, 0xD7, 0x00, 0xD0, 0xA6, 0x6A, 0x06, 0x50, 0x08, 0xD8, 0x38, 0xDF, 0x00, 0x50, 0x05, 0xD8, 
	0x01, 0x50, 0x03, 0xD8, 0x04, 0x0E, 0x0D, 0xD8, 0xE5, 0xD6, 0x03, 0x6E, 0x0F, 0x0A, 0x06, 0xE0, 
	0x03, 0x50, 0x04, 0x0A, 0x03, 0xE0, 0x03, 0x50, 0x05, 0x0A, 0x02, 0xE1, 0x05, 0x0E, 0x01, 0xD8, 
	0x03, 0x50, 0x04, 0x00, 0xA4, 0xA8, 0xFE, 0xD7, 0x73, 0x6E, 0x12, 0x00, 0x71, 0xB2, 0xFF, 0x00, 
	0x04, 0x00, 0xA4, 0xAA, 0xFD, 0xD7, 0x74, 0x50, 0x02, 0x6E, 0x12, 0x00, 0xFF, 0x00, 0xFF, 0x00, 
	0xFF, 0x00, 0xA6, 0x6A, 0xF5, 0x6E, 0x0C, 0x00, 0x04, 0x00, 0x04, 0x50, 0xA7, 0x6E, 0x05, 0x50, 
	0xA7, 0x6E, 0xA6, 0x82, 0x00, 0x00, 0x12, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};      


unsigned char checkbootloader(void) {
    unsigned int adr, i=0, cnt;
    unsigned char err=0, errcnt=0;
    
    INTCONbits.GIE = 0;                                                         // Disable interrupts
    
    EECON1 = 0x80;                                                              // Access Flash program memory
       
    TBLPTR = 0xFFF0;                                                            // set to serial nr.
    asm("TBLRD*+");
    serialnr = TABLAT;                                                          // first read LSB
    asm("TBLRD*+");
    serialnr |= TABLAT<<8;                                                      // then MSB

    TBLPTR = 0xFFD0;                                                            // Address unused by 1.05 bootloader, should be 0xff
    asm("TBLRD*+");
    if (TABLAT != 0xFF) {
        INTCONbits.GIE = 1;                                                     // Enable interrupts
        return 0;                                                               // already updated to 1.06 or higher
    }

    // now erase and overwrite the bootloader @ FD00-FFFF, 12 blocks of 64 bytes

    unlock55 = unlockMagic + 0x33u;                                             // to protect against unintended flash writes/erase 
    unlockAA = unlockMagic + 0x88u;                                             // we calculate the magic values
    
    do {
        i = 0;
        err = 0;
        adr = 0xFD00;
        do {
            memcpy(GLCDbuf, bootloader+i, 64);                                  // copy 64 bytes to temp buffer
            if (i == 0x2c0) {
                GLCDbuf[48] = serialnr & 0xff;
                GLCDbuf[49] = serialnr >> 8;
                GLCDbuf[50] = 0;
                GLCDbuf[51] = 0;
            }

            TBLPTR = adr;                                                       // set pointer to start of block to erase
            EECON1 = 0x94;                                                      // select erase, and set write enable     
            EECON2 = unlock55;
            EECON2 = unlockAA;                                                  // write magic values to enable erase
            EECON1bits.WR = 1;                                                  // start the actual erase

            TBLPTR = adr;                                                       // set pointer to start of block to erase         
            cnt = 0;
            do {
                TABLAT = GLCDbuf[i%64];                                         // No debug print here, as it will modify the TBLPTR
                i++;
                asm("TBLWT*+");                                                 // write to latch and increment
            } while (++cnt <64);

            asm("TBLRD*-");                                                     // dummy read to point to the correct flash block
            EECON1 = 0x84;                                                      // select flash write, and set write enable     
            EECON2 = unlock55;
            EECON2 = unlockAA;                                                  // write magic values to enable erase
            EECON1bits.WR = 1;                                                  // start the actual programming

            EECON1 = 0x80;                                                      // write disable
            TBLPTR = adr;
            i -=64;

            cnt = 0;
            do {
                asm("TBLRD*+");                                                 // read back flash
                if (TABLAT != GLCDbuf[i%64]) err = 1;                           // and verify with buffer
                i++;
            } while (++cnt <64);

            adr +=64;
        } while (adr);
    
    } while (err && ++errcnt < 3);                                              // try three times
    
    EECON1bits.WREN = 0;
    
    unlock55 = 0;
    unlockAA = 0;
    INTCONbits.GIE = 1;                                                         // Enable interrupts
    if (err) return 2;
    return 1;
}

